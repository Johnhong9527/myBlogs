{"./":{"url":"./","title":"关于本文档","keywords":"","body":"介绍 都是一些琐碎的笔记 在线地址 "},"JavaScript/principle/":{"url":"JavaScript/principle/","title":"原理解析","keywords":"","body":"原理解析 "},"JavaScript/principle/0_data_type.html":{"url":"JavaScript/principle/0_data_type.html","title":"数据类型","keywords":"","body":"数据类型 window.onload = () => { var test1 = \"abcdef\"; var test2 = 123; var test3 = true; var test4 = {}; var test5 = []; var test6; var test7 = { \"abcdef\": 123 }; var test8 = [\"abcdef\", 123]; function test9() { return \"abcdef\" }; var test10 = null; var test11 = 'q58'; var test12 = '张'; var test13 = '78'; console.log(typeof test1); // string console.log(typeof test2); // number console.log(typeof test3); // boolean console.log(typeof test4); // object console.log(typeof test5); // object console.log(typeof test6); // undefined console.log(typeof test7); // object console.log(typeof test8); // object console.log(typeof test9); // function console.log(typeof test10); // object // # 无法转为数字的为true console.log(isNaN(test11)); // true console.log(isNaN(test12)); // true console.log(isNaN(test13)); // false // 数值比较 console.log(\"1\" - \"1\"); // 5个假值：undefined null “” 0 NaN // ** 字符串方法 ** // toLowerCase() 字符串大写 =>小写 // toUpperCase() 字符串小写 => 大写 // replace() 查找子串并将他们都替换为另一个字符串 // slice() 删除字符串的一部分并返回结果 // indexOf() 从头部开始查找子串,返回下标 // lastIndexOf() 查找最后一个子串,返回下标 // concat() 将字符串拼接起来 // match() 在字符串中查找与正则表达啥匹配的子串 // trim() 删除字符串开头和末尾的的空白字符, let phone = \"123-8568\"; function phoneF(number) { return number.match(/^\\d{3}-?\\d{4}$/); } console.log(phoneF(phone)); // 实例化对象 function Duck(sound) { this.sound = sound; this.quack = () => { console.log(this.sound) } } let toy = new Duck('quack quack'); toy.quack(); console.log(typeof toy); // object console.log(toy instanceof Duck); // true } "},"JavaScript/principle/001_object.html":{"url":"JavaScript/principle/001_object.html","title":"Object","keywords":"","body":"Object 判断 obj 对象 参考文章:判断 JS 数据类型的 4 种方法 typeof /* typeof 是一个操作符，其右侧跟一个一元表达式， 并返回这个表达式的数据类型。 返回的结果用该类型的字符串(全小写字母)形式表示， 包括以下 7 种： number、boolean、symbol、string、 object、undefined、function 等。 */ typeof ''; // string 有效 typeof 1; // number 有效 typeof Symbol(); // symbol 有效 typeof true; //boolean 有效 typeof undefined; //undefined 有效 typeof null; //object 无效 typeof [] ; //object 无效 typeof new Function(); // function 有效 typeof new Date(); //object 无效 typeof new RegExp(); //object 无效 /* 其他正确,但不符合判断的结果 对于基本类型，除 null 以外，均可以返回正确的结果。 对于引用类型，除 function 以外，一律返回 object 类型。 对于 null ，返回 object 类型。 对于 function 返回 function 类型。 */ instanceof instanceof认为能够判断出 [ ] 是Array的实例，但它认为 [ ] 也是Object的实例 why? 从 instanceof 能够判断出 [ ].proto 指向 Array.prototype，而 Array.prototype.proto 又指向了Object.prototype，最终 Object.prototype.proto 指向了null，标志着原型链的结束。因此，[]、Array、Object 就在内部形成了一条原型链： // 内部执行过程 function instanceof (A,B) = { var L = A.__proto__; var R = B.prototype; if(L === R) { // A的内部属性 __proto__ 指向 B 的原型对象 return true; } return false; } constructor使用技巧 toString Object.prototype.toString.call('') ; // [object String] Object.prototype.toString.call(1) ; // [object Number] Object.prototype.toString.call(true) ; // [object Boolean] Object.prototype.toString.call(Symbol()); //[object Symbol] Object.prototype.toString.call(undefined) ; // [object Undefined] Object.prototype.toString.call(null) ; // [object Null] Object.prototype.toString.call(new Function()) ; // [object Function] Object.prototype.toString.call(new Date()) ; // [object Date] Object.prototype.toString.call([]) ; // [object Array] Object.prototype.toString.call(new RegExp()) ; // [object RegExp] Object.prototype.toString.call(new Error()) ; // [object Error] Object.prototype.toString.call(document) ; // [object HTMLDocument] Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用 代码风格 let time = { a: function(a) { console.log(a); }, b: function(b) { console.log(\"b:\" + b); }, }; time.b(385); es6 常见代码片段 // 获取对象的key Object.keys({ name: \"seamong\", age: 1 }); // 获取对象里数据的数量 Object.keys({ name: \"seamong\", age: 1 }).length; // 遍历数组 Object.entries({ name: \"seamong\", age: 1 }); // extend功能 const obj = { name: \"seamong\", age: 3 }; const newObj = { ...obj, job: \"IT\", age: 18 }; console.log(newObj); // 获取列表的头和尾 const [head, ...tail] = [1, 2, 3]; const [head, ...initial] = [1, 2, 3].reverse(); "},"JavaScript/principle/002_array.html":{"url":"JavaScript/principle/002_array.html","title":"Array","keywords":"","body":"Array 常见代码片段 // 判断数组 const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; const obj = { name: \"hello\", age: 1 }; // instanceof方法(推荐使用) console.log(arr instanceof Array); //true console.log(arr instanceof Object); //true,在数组的原型链上也能找到Object构造函数 console.log(obj instanceof Array); //false // constructor方法(不推荐:constructor方法可以被修改) const a = []; const b = {}; const c = /^[0-9]$/; console.log(a.constructor == Array); //true console.log(b.constructor == Array); //false console.log(c.constructor == Array); //false // 不推荐理由 const a = []; //作死将constructor属性改成了别的 a.contrtuctor = Object; console.log(a.constructor == Array); //false (哭脸) console.log(a.constructor == Object); //true (哭脸) console.log(a instanceof Array); //true (instanceof火眼金睛) // 用Object的toString方法 const a = [\"Hello\", \"Howard\"]; const b = { 0: \"Hello\", 1: \"Howard\" }; const c = \"Hello Howard\"; console.log(a.toString()); //\"Hello,Howard\" console.log(b.toString()); //\"[object Object]\" console.log(c.toString()); //\"Hello,Howard\" // 通过改变toString执行时的上下文判断是否为数组 // call | apply Object.prototype.toString.call(a); // [object Array] Object.prototype.toString.call(b); // [object Object] Object.prototype.toString.call(c); // [object String] // or Object.prototype.toString.apply(a); //\"[object Array]\" Object.prototype.toString.apply(b); //\"[object Object]\" Object.prototype.toString.apply(c); //\"[object String]\" // 合并上述过程为函数 const isArray = (something)=>{ return Object.prototype.toString.call(something) === '[object Array]'; } const a = []; const b = {}; isArray(a);//true isArray(b);//false // 用Array对象的isArray方法判断 const a = []; const b = {}; Array.isArray(a);//true Array.isArray(b);//false Object.prototype.toString = ()=>{ console.log('Hello Howard'); } const a = []; Array.isArray(a);//true // 兼容性写法 if (!Array.isArray) { Array.isArray = function(arg) { return Object.prototype.toString.call(arg) === '[object Array]'; }; } // jquery方法判断 // 待续 es6 常见代码片段 // 遍历数组 [1, 2, 3].forEach(function(value, index) { console.log(value); }); // 映射新数组 arr = [1, 2, 3].map(v => v * 2); // 所有元素是否通过测试 [1, 2, , 3, 4].every(v => v > 3); // 是否有元素通过测试 [1, 2, , 3, 4].some(v => v > 3); // 过滤数组 [1, 2, 3, 4, 5].filter(v => v > 3); // 查找符合条件的元素: arr = [{ name: \"dashing\", age: 18 }, { name: \"rmos\", age: 1 }]; // 查找索引 [1, 2, 3].indexOf(2); // 连接数组 arr1 = [1, 2, 3]; arr2 = [4, 5, 6]; [...arr1, ...arr2]; //数组去重 arr = [1, 2, 3, 4, 3, 2, 1]; [...new Set(arr)]; "},"JavaScript/principle/002_DOM.html":{"url":"JavaScript/principle/002_DOM.html","title":"DOM","keywords":"","body":"DOM "},"JavaScript/principle/01.html":{"url":"JavaScript/principle/01.html","title":"HTML DOM Document 对象","keywords":"","body":"HTML DOM Document 对象 给文档对象添加/移除事件句柄 let btnEnter = document.getElementById('btnEnter'); function btn(){ alert('单击事件,被触发'); } /* # addEventListener: 给文档对象添加事件句柄 # 语法: document.addEventListener(event,function,useCapture) # event: 必需。描述事件名称的字符串。 # function: 必需。描述了事件触发后执行的函数。 # useCapture: 可选: # true - 事件句柄在捕获阶段执行 # false- 默认。事件句柄在冒泡阶段执行 */ btnEnter.addEventListener('click',btn()) /*您可以通过函数名来引用外部函数：*/ document.addEventListener(\"click\", myFunction); function myFunction() { document.getElementById(\"demo\").innerHTML = \"Hello World\"; } /* # reamveEventListener: 移除文档中的事件句柄 # 语法: document.remaveEventListener(event,function,useCapture) # event: 必需。要移除的事件名称。 # function: 必需。指定要移除的函数。 # useCapture: 可选: # true - 事件句柄在捕获阶段移除 # false- 默认。事件句柄在冒泡阶段移除 */ // removeEventListener // 移除文档对象已添加的事件句柄 btnEnter.removeEventListener('click',btn()) 返回当前获取焦点元素 语法: doucment.activeElement.tagName 定义和使用: activeElement 属性返回文档中当前获得焦点的元素。 btnName let name = document.getElementById('name'); let btnName = document.getElementById('btnName'); let btns = document.getElementById('btns'); 用法一(获取子元素焦点事件名称): btnS.addEventListener('click',function () { console.log(document.activeElement.tagName) // 输出所有子元素的焦点事件名称 }) 用法二(元素本身的焦点事件名称): name.addEventListener('click',function(){ console.log(document.activeElement.tagName); }) 　添加class属性 // 添加class属性 pater1.setAttribute(\"class\", \"redtext\"); // 获取class属性 :只对 ID 有效，class无效 let href = document.getElementById('href'); console.log(href.getAttribute('href')); "},"JavaScript/principle/02.html":{"url":"JavaScript/principle/02.html","title":"闭包","keywords":"","body":"闭包 下面是一个简单的闭包 function foo(x) { var tmp = 3; function bar(y) { alert(x + y + (++tmp)); } bar(10); } foo(2) 概念 闭包就是能够读取其他函数内部变量的函数。也可以理解成：定义再一个函数内部的函数。 作用 理解函数内部与外部的桥梁 用途 1.可以读取函数内部的变量。 2.让这些变量始终保持在内存中。 实例+分析 简单来说 getNameFunc() 是一个闭包函数， 我们在 对象 Object 中，定义了它。 接着定义了 var that=this; 并且在 getNameFunc() 里面，return 一个匿名函数， return 返回 that.name 和 this.name; 这个时候发现 that.name; ==>\"My Object\"; 为什么这个时候 this.name 的值是 \"My Object\" 而不是\"The Window\"。 this.name 这个时候，表示的是内部对象 Object 中定义的 name 的值。 这个name的值，初始是 \"My Object\" ，但是在 Object.getNameFunc() 运行之后， this 就不在表示 Object ，而是指代全局了。 那么这样子的话.不论我们如何去定义 this.name 的值。 全局中，var name = \"The Window\"; 被定义了。 我们这个时候 去输出 this.name 的话.结果都是 \"The Window\"。 那么为什么在 Object.getNameFunc() 函数运作之后，this 就表示全局了呢？ getNameFunc();是一个闭包函数。当我们运行它的时候。它被赋予全局变量 它就被存入到内存中。 var name = \"The Window\"; var object = { name : \"My Object\", getNameFunc : function(){ var that=this; return function(){ return 'that:'+that.name+';this:'+this.name; }; } }; console.log(object.getNameFunc()());//that:My Object;this:The Window 从技术上来讲，在JS中，每个function都是闭包，因为它总是能访问在它外部定义的数据。 "},"JavaScript/principle/03.html":{"url":"JavaScript/principle/03.html","title":"写给初级JS程序员的JavaScript闭包(译)","keywords":"","body":"写给初级JS程序员的JavaScript闭包(译) 原文链接 闭包不是魔术 这个页面解释了closures，以便程序员可以理解它们 - 使用有效的JavaScript代码。它不是用于古茹或功能程序员。 一旦核心概念被解构，闭包不难理解。然而，他们不可能通过阅读任何学术论文或面向学术的信息来了解他们！ 本文主要面向有主流语言编程经验的程序员，他们可以阅读以下JavaScript函数： function sayHello(name) { var text = 'Hello ' + name; var say = function() { console.log(text); } say(); } sayHello('Joe'); 闭包的实例 两句话摘要：     .它是一个可以引用其范围内的变量（在第一次声明时），被赋值给变量，作为参数传递给函数或作为函数结果返回的表达式。     .闭包是一个堆栈框架，当函数开始执行时被分配，并且在函数返回之后不被释放（就好像“堆栈框架”在堆上分配而不是堆栈！）。 以下代码返回对函数的引用： function sayHello2(name) { var text = 'Hello ' + name; // Local variable var say = function() { console.log(text); } return say; } var say2 = sayHello2('Bob'); say2(); // logs \"Hello Bob\" 大多数JavaScript程序员将会理解在上面的代码中如何将一个函数的引用返回给一个变量。如果你没有，那么你需要在你可以学习闭包。AC程序员会认为函数返回一个指向函数的指针，变量sayAlert和say2都是指向函数的指针。 在指向函数的C指针和对函数的JavaScript引用之间存在关键的区别。在JavaScript中，您可以将函数引用变量看作具有指向函数的指针 以及指向闭包的隐藏指针。 上面的代码有一个闭包，因为匿名函数function（）{alert（text）; } 在另一个函数中声明，在这个例子中为sayHello2（）。在JavaScript中，如果在另一个函数中使用function关键字，则要创建一个闭包。 在C和大多数其他常用语言函数返回后，所有的局部变量不再可访问，因为堆栈帧被销毁。 在JavaScript中，如果在另一个函数中声明一个函数，那么在从调用的函数返回后，局部变量仍然可以访问。这是上面演示的，因为我们调用函数say2（）; 之后我们从sayHello2（）返回。请注意，我们调用的代码引用变量text，它是函数sayHello2（）的局部变量。 function() { console.log(text); } // Output of say2.toString(); 看看输出say2.toString()，我们可以看到代码引用的变量text。匿名函数可以引用text保存值的值'Hello Bob'，因为局部变量sayHello2()保存在闭包中。 神奇的是，在JavaScript中，函数引用还具有对其创建的闭包的秘密引用 - 类似于如何委托是方法指针加上对对象的秘密引用。 更多例子 出于某种原因，当你阅读关于它们的闭包似乎真的很难理解，但当你看到一些例子，你可以点击他们的工作（它花了我一段时间）。我建议仔细阅读示例，直到你了解它们如何工作。如果你开始使用闭包没有完全了解它们如何工作，你很快就会创建一些非常古怪的错误！ 例3 此示例显示不复制局部变量 - 它们通过引用保留。它是一种像在外部函数退出时在内存中保留一个堆栈框架！ function say667() { // Local variable that ends up within closure var num = 42; var say = function() { console.log(num); } num++; return say; } var sayNumber = say667(); sayNumber(); // logs 43 例4 所有三个全局函数具有对同一闭包的公共引用，因为它们都在单个调用中声明setupSomeGlobals()。 var gLogNumber, gIncreaseNumber, gSetNumber; function setupSomeGlobals() { // Local variable that ends up within closure var num = 42; // Store some references to functions as global variables gLogNumber = function() { console.log(num); } gIncreaseNumber = function() { num++; } gSetNumber = function(x) { num = x; } } setupSomeGlobals(); gIncreaseNumber(); gLogNumber(); // 43 gSetNumber(5); gLogNumber(); // 5 var oldLog = gLogNumber; setupSomeGlobals(); gLogNumber(); // 42 oldLog() // 5 这三个函数具有对同一闭包的共享访问 - setupSomeGlobals()当定义三个函数时的局部变量。 注意，在上面的例子中，如果setupSomeGlobals()再次调用，则创建一个新的闭包（stack-frame！）。老gLogNumber，gIncreaseNumber，gSetNumber变量将覆盖新的具有新功能关闭。（在JavaScript中，当你声明另一个函数内的函数，里面的功能（s）是/再次重新创建每个外部函数被调用时）。 例5 这是一个真正的困扰，许多人，所以你需要了解它。要非常小心，如果你在一个循环中定义一个函数：从闭包的局部变量不会像你可能会想的那样。 function buildList(list) { var result = []; for (var i = 0; i line result.push（function（）{console.log（item +''+ list [i]）}在结果数组中添加一个对匿名函数的引用三次。如果你不熟悉匿名函数， 就如： pointer = function() {console.log(item + ' ' + list[i])}; result.push(pointer); 注意，当运行示例时，“item2 undefined”会提醒三次！ 这是因为就像前面的例子一样，buildList的局部变量只有一个闭包。 当在fnlist [j]（）上调用匿名函数时; 它们都使用相同的单个闭包，并且它们使用该闭包内的i和项的当前值（其中i具有值3，因为循环已完成，并且项具有值'item2'）。 注意，我们从0索引，因此项目的值为item2。 并且i ++将i增加到值3。 例6 此示例显示，闭包包含在退出前在外部函数中声明的任何局部变量。 注意，变量alice实际上是在匿名函数之后声明的。 匿名函数首先声明; 并且当调用该函数时，它可以访问alice变量，因为alice在同一范围内（JavaScript变量提升）。 另外sayAlice（）（）只是直接调用从sayAlice（）返回的函数引用 - 它完全与以前做过的相同，但没有临时变量。 function sayAlice() { var say = function() { console.log(alice); } // Local variable that ends up within closure var alice = 'Hello Alice'; return say; } sayAlice()();// logs \"Hello Alice\" Tricky：还要注意，say变量也在闭包内，并且可以被可能被声明的任何其他函数访问sayAlice()，或者它可以在内部函数内被递归地访问。 例7 最后一个例子显示每个调用为局部变量创建一个单独的闭包。 每个函数声明没有单个闭包。 每个函数的调用都有一个闭包。 function newClosure(someNum, someRef) { // Local variables that end up within closure var num = someNum; var anArray = [1,2,3]; var ref = someRef; return function(x) { num += x; anArray.push(num); console.log('num: ' + num + '; anArray: ' + anArray.toString() + '; ref.someVar: ' + ref.someVar + ';'); } } obj = {someVar: 4}; fn1 = newClosure(4, obj); fn2 = newClosure(5, obj); fn1(1); // num: 5; anArray: 1,2,3,5; ref.someVar: 4; fn2(1); // num: 6; anArray: 1,2,3,6; ref.someVar: 4; obj.someVar++; fn1(2); // num: 7; anArray: 1,2,3,5,7; ref.someVar: 5; fn2(2); // num: 8; anArray: 1,2,3,6,8; ref.someVar: 5; 概要 如果一切似乎完全不清楚，那么最好的办法是玩的例子。阅读解释比理解示例困难得多。我对闭包和堆栈框架等的解释在技术上是不正确的 - 它们是用于帮助理解的粗略简化。一旦基本的想法是grokked，你可以提取细节后。 总结: 1.当你function在另一个函数里面使用时，使用闭包。 2.每当在函数中使用eval（）时，都会使用闭包。 eval的文本可以引用函数的局部变量，在eval中甚至可以使用eval（'var foo = ...'）创建新的局部变量 3.当在函数中使用新的Function（...）（Function构造函数）时，它不会创建闭包。 （新函数不能引用外层函数的局部变量。） 4.JavaScript中的闭包就像保留所有局部变量的副本，就像函数退出时一样。 5.最好是认为闭包始终只创建一个函数的入口，局部变量将添加到闭包中。 6.每次调用具有闭包的函数时，都会保存一组新的局部变量（假定函数在其中包含函数声明，并且对该函数的引用要么返回，要么以某种方式保留外部引用 ）。 7.两个函数可能看起来像它们具有相同的源文本，但是具有完全不同的行为，因为它们的“隐藏”闭包。 我不认为JavaScript代码实际上可以找出一个函数引用是否有闭包。 8.如果你试图做任何动态源代码修改（例如：myFunction = Function（myFunction.toString（）。replace（/ Hello /，'Hola'））;），如果myFunction是一个闭包 当然，你永远不会想到在运行时做源代码字符串替换，但...）。 9.可以在函数内的函数声明中获得函数声明 - 你可以在多个级别获得闭包。 10.我认为通常闭包是函数和捕获的变量的术语。 注意，我在本文中不使用这个定义！ 11.我怀疑JavaScript中的闭包不同于通常在函数式语言中发现的闭包。 链接: 1.Douglas Crockford的模拟私有属性和一个对象的私有方法，使用闭包。 2.一个伟大的解释如何闭包可以导致内存泄漏在IE如果你不小心。 感谢 如果你刚刚学到了闭包（在这里或其他地方！），那么我有兴趣任何反馈从您的任何更改，你可能建议，可以使本文更清楚。 发送电子邮件至morrisjohns.com（morris_closure @）。 请注意，我不是JavaScript的上师 - 也不是关闭。 "},"JavaScript/principle/04.html":{"url":"JavaScript/principle/04.html","title":"匿名函数和闭包","keywords":"","body":"匿名函数和闭包 在计算机科学中，闭包是函数的非局部变量（自由变量）的引用环境。 包含自由变量的函数与为所有这些自由变量提供了变量绑定的环境一起,被称为闭包。 以下内容为学习笔记，来自李炎恢老师的课堂纪要。 1.匿名函数 普通函数 function box() { //函数名是box return 'Lee'; } 匿名函数 function () { //匿名函数，会报错 return 'Lee'; } 通过表达式自我执行 (function box() { //封装成表达式 alert('Lee'); })(); //()表示执行函数，并且传参 把匿名函数赋值给变量 var box = function () { //将匿名函数赋给变量 return 'Lee'; }; alert(box()); //调用方式和函数调用相似 函数里的匿名函数 function box () { return function () { //函数里的匿名函数，产生闭包 return 'Lee'; } } alert(box()()); //调用匿名函数 2.闭包 闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的常见的方式，就是在 一个函数内部创建另一个函数，通过另一个函数访问这个函数的局部变量。 通过闭包可以返回局部变量 function box() { var user = 'Lee'; return function () { //通过匿名函数返回box()局部变量 return user; }; } alert(box()()); //通过box()()来直接调用匿名函数返回值 var b = box(); alert(b()); //另一种调用匿名函数返回值 使用闭包有一个优点，也是它的缺点：就是可以把局部变量驻留在内存中，可以避免使 用全局变量。(全局变量污染导致应用程序不可预测性，每个模块都可调用必将引来灾难， 所以推荐使用私有的，封装的局部变量)。 通过全局变量来累加 var age = 100; //全局变量 function box() { age ++; //模块级可以调用全局变量，进行累加 } box(); //执行函数，累加了 alert(age); //输出全局变量 //通过局部变量无法实现累加 function box() { var age = 100; age ++; //累加 return age; } alert(box()); //101 alert(box()); //101，无法实现，因为又被初始化了 通过闭包可以实现局部变量的累加 function box() { var age = 100; return function () { age ++; return age; } } var b = box(); //获得函数 alert(b()); //调用匿名函数 alert(b()); //第二次调用匿名函数，实现累加 循环里包含匿名函数 function box() { var arr = []; for (var i = 0; i 上面的例子输出的结果都是5，也就是循环后得到的最大的i 值。因为b[i]调用的是匿 名函数，匿名函数并没有自我执行，等到调用的时候，box()已执行完毕，i 早已变成5，所 以最终的结果就是5 个5。 循环里包含匿名函数-改1，自我执行匿名函数 function box() { var arr = []; for (var i = 0; i 改1 中，我们让匿名函数进行自我执行，导致最终返回给a[i]的是数组而不是函数了。 最终导致b[0]-b[4]中保留了0,1,2,3,4 的值。 循环里包含匿名函数-改2，匿名函数下再做个匿名函 function box() { var arr = []; for (var i = 0; i 改1 和改2 中，我们通过匿名函数自我执行，立即把结果赋值给a[i]。每一个i，是调 用方通过按值传递的，所以最终返回的都是指定的递增的i。而不是box()函数里的i。 关于this 对象 在闭包中使用this 对象也可能会导致一些问题，this 对象是在运行时基于函数的执行环 境绑定的，如果this 在全局范围就是window，如果在对象内部就指向这个对象。而闭包却 在运行时指向window 的，因为闭包并不属于这个对象的属性或方法。 var user = 'The Window'; var obj = { user : 'The Object', getUserFunction : function () { return function () { //闭包不属于obj，里面的this 指向window return this.user; }; } }; alert(obj.getUserFunction()()); //The window //可以强制指向某个对象 alert(obj.getUserFunction().call(obj)); //The Object //也可以从上一个作用域中得到对象 getUserFunction : function () { var that = this; //从对象的方法里得对象 return function () { return that.user; }; } 内存泄漏 由于IE 的JScript 对象和DOM 对象使用不同的垃圾收集方式，因此闭包在IE 中会导致 一些问题。就是内存泄漏的问题，也就是无法销毁驻留在内存中的元素。以下代码有两个知 识点还没有学习到，一个是DOM，一个是事件。 function box() { var oDiv = document.getElementById('oDiv'); //oDiv 用完之后一直驻留在内存 oDiv.onclick = function () { alert(oDiv.innerHTML); //这里用oDiv 导致内存泄漏 }; } box(); 那么在最后应该将oDiv 解除引用来避免内存泄漏。 function box() { var oDiv = document.getElementById('oDiv'); var text = oDiv.innerHTML; oDiv.onclick = function () { alert(text); }; oDiv = null; //解除引用 } PS：如果并没有使用解除引用，那么需要等到浏览器关闭才得以释放。 模仿块级作用域 JavaScript 没有块级作用域的概念。 function box(count) { for (var i=0; i 以上两个例子，说明JavaScript 没有块级语句的作用域，if () {} for () {}等没有作用域， 如果有，出了这个范围i 就应该被销毁了。就算重新声明同一个变量也不会改变它的值。 JavaScript 不会提醒你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声 明视而不见(如果初始化了，当然还会执行的)。使用模仿块级作用域可避免这个问题。 模仿块级作用域(私有作用域) (function () { //这里是块级作用域 })(); //使用块级作用域(私有作用域)改写 function box(count) { (function () { for (var i = 0; i 使用了块级作用域(私有作用域)后，匿名函数中定义的任何变量，都会在执行结束时被 销毁。这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的 变量和函数。一般来说，我们都应该尽可能少向全局作用域中添加变量和函数。在大型项目 中，多人开发的时候，过多的全局变量和函数很容易导致命名冲突，引起灾难性的后果。如 果采用块级作用域(私有作用域)，每个开发者既可以使用自己的变量，又不必担心搞乱全局 作用域。 (function () { var box = [1,2,3,4]; alert(box); //box 出来就不认识了 })(); 在全局作用域中使用块级作用域可以减少闭包占用的内存问题，因为没有指向匿名函数 的引用。只要函数执行完毕，就可以立即销毁其作用域链了。 私有变量 JavaScript 没有私有属性的概念；所有的对象属性都是公有的。不过，却有一个私有变 量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问 这些变量。 function box() { var age = 100; //私有变量，外部无法访问 } 而通过函数内部创建一个闭包，那么闭包通过自己的作用域链也可以访问这些变量。而 利用这一点，可以创建用于访问私有变量的公有方法。 function Box() { var age = 100; //私有变量 function run() { //私有函数 return '运行中...'; } this.get = function () { //对外公共的特权方法 return age + run(); }; } var box = new Box(); alert(box.get()); 可以通过构造方法传参来访问私有变量 function Person(value) { var user = value; //这句其实可以省略 this.getUser = function () { return user; }; this.setUser = function (value) { user = value; }; } 但是对象的方法，在多次调用的时候，会多次创建。可以使用静态私有变量来避免这个 问题。 静态私有变量 通过块级作用域(私有作用域)中定义私有变量或函数，同样可以创建对外公共的特权方 法。 (function () { var age = 100; function run() { return '运行中...'; } Box = function () {}; //构造方法 Box.prototype.go = function () { //原型方法 return age + run(); }; })(); var box = new Box(); alert(box.go()); 上面的对象声明，采用的是Box = function () {} 而不是function Box() {} 因为如果用后 面这种，就变成私有函数了，无法在全局访问到了，所以使用了前面这种。 (function () { var user = ''; Person = function (value) { user = value; }; Person.prototype.getUser = function () { return user; }; Person.prototype.setUser = function (value) { user = value; } })(); 使用了prototype 导致方法共享了，而user 也就变成静态属性了。(所谓静态属性，即共 享于不同对象中的属性)。 模块模式 之前采用的都是构造函数的方式来创建私有变量和特权方法。那么对象字面量方式就采 用模块模式来创建。 var box = { //字面量对象，也是单例对象 age : 100, //这是公有属性，将要改成私有 run : function () { //这时公有函数，将要改成私有 return '运行中...'; }; }; 私有化变量和函数 var box = function () { var age = 100; function run() { return '运行中...'; } return { //直接返回对象 go : function () { return age + run(); } }; }(); 上面的直接返回对象的例子，也可以这么写 var box = function () { var age = 100; function run() { return '运行中...'; } var obj = { //创建字面量对象 go : function () { return age + run(); } }; return obj; //返回这个对象 }(); 字面量的对象声明，其实在设计模式中可以看作是一种单例模式，所谓单例模式，就是 永远保持对象的一个实例。 增强的模块模式，这种模式适合返回自定义对象，也就是构造函数。 function Desk() {}; var box = function () { var age = 100; function run() { return '运行中...'; } var desk = new Desk(); //可以实例化特定的对象 desk.go = function () { return age + run(); }; return desk; }(); alert(box.go()); "},"JavaScript/principle/05.html":{"url":"JavaScript/principle/05.html","title":"instanceof运算符","keywords":"","body":"instanceof运算符 原文 语法 object instanceof constructor 参数 object 要检测的对象. constructor 某个构造函数 描述 instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。 // 定义构造函数 function C(){} function D(){} var o = new C(); // true，因为 Object.getPrototypeOf(o) === C.prototype o instanceof C; // false，因为 D.prototype不在o的原型链上 o instanceof D; o instanceof Object; // true,因为Object.prototype.isPrototypeOf(o)返回true C.prototype instanceof Object // true,同上 C.prototype = {}; var o2 = new C(); o2 instanceof C; // true o instanceof C; // false,C.prototype指向了一个空对象,这个空对象不在o的原型链上. D.prototype = new C(); // 继承 var o3 = new D(); o3 instanceof D; // true o3 instanceof C; // true 需要注意的是，如果表达式 obj instanceof Foo 返回true，则并不意味着该表达式会永远返回true，因为Foo.prototype属性的值有可能会改变，改变之后的值很有可能不存在于obj的原型链上，这时原表达式的值就会成为false。另外一种情况下，原表达式的值也会改变，就是改变对象obj的原型链的情况，虽然在目前的ES规范中，我们只能读取对象的原型而不能改变它，但借助于非标准的proto魔法属性，是可以实现的。比如执行obj.proto = {}之后，obj instanceof Foo就会返回false了。 instanceof和多全局对象(多个frame或多个window之间的交互) 在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。这可能会引发一些问题。比如，表达式 [] instanceof window.frames[0].Array 会返回false，因为 Array.prototype !== window.frames[0].Array.prototype，因此你必须使用 Array.isArray(myObj) 或者 Object.prototype.toString.call(myObj) === \"[object Array]\"来判断myObj是否是数组。 例子 例子: 表明String对象和Date对象都属于Object类型 下面的代码使用了instanceof来证明：String和Date对象同时也属于Object类型。 var simpleStr = \"This is a simple string\"; var myString = new String(); var newStr = new String(\"String created with constructor\"); var myDate = new Date(); var myObj = {}; simpleStr instanceof String; // returns false, 检查原型链会找到 undefined myString instanceof String; // returns true newStr instanceof String; // returns true myString instanceof Object; // returns true myObj instanceof Object; // returns true, despite an undefined prototype ({}) instanceof Object; // returns true, 同上 myString instanceof Date; // returns false myDate instanceof Date; // returns true myDate instanceof Object; // returns true myDate instanceof String; // returns false 演示mycar属于Car类型的同时又属于Object类型 下面的代码创建了一个类型Car，以及该类型的对象实例mycar. instanceof运算符表明了这个mycar对象既属于Car类型，又属于Object类型。 function Car(make, model, year) { this.make = make; this.model = model; this.year = year; } var mycar = new Car(\"Honda\", \"Accord\", 1998); var a = mycar instanceof Car; // 返回 true var b = mycar instanceof Object; // 返回 true instanceof运算符在数组中的使用 确定一个对象在全局中是否为数组 var colors=['aa','bb','cc'];//创建包含三个字符串的数组 if (colors instanceof Array){ alert(1) }else { alert(0) } //最后输出 1，说明该对象为数组 "},"JavaScript/principle/06.html":{"url":"JavaScript/principle/06.html","title":"JavaScript事件流","keywords":"","body":"JavaScript事件流 定义 申明：本文仅限私人学习之用---- 原文； 下图展示了完整的js事件流 捕获阶段：Document==>ElementHtml==>ElementBody==>ElementDiv 冒泡阶段：ElementDiv==>ElementBody==>ElementHtml==>Document 分析 捕获阶段： document对象首先接收到click事件，然后事件沿DOM树依次向下，一直传播到事件的实际目标。 冒泡阶段： IE的事件流叫做事件冒泡（event bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（ 文档）。 事件处理程序 html事件处理程序 事件对象： event:不是自己定义的，是給元素綁定事件之后，自动生成的局部变量，表示事件对象。 this:在函數內部，等于事件的目标元素；在函數內部可以像访问局部变量一样访问document及该元素本身的成员。 //如果当前元素是一個表单的輸入元素，则作用域中还会包含访问表单元素（父元素）的入口 (function(){ with(document){ with(this.from){ //元素属性值 } } })() 缺点： 1.时差问题，用戶可能会在HTML元素一出現在页面上时，就触发相应事件， 但当时该事件有可能不具备执行条件。 2.这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。 不同JavaScript引擎遵循的标识符解析规则略有差异， 很可能会在访问非限定对象成员时出错。(高耦合) DOM0级事件处理程序 通过js指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性 //创建 var btn = document.getElementById(\"myBtn\"); btn.onclick=function(){ alert(\"Clicked\"); } //删除 btn.onclick=null; DOM2级事件处理程序 addEventListener() 为指定事件添加处理程序 // 下面这段程序中因为添加了false，所以该事件会在冒泡阶段被触发 var btn=document.getElementById('myBtn'); btn.addEventListener(\"click\",function(){ alert(\"this.id\"); },false); // 使用 DOM2 级方法添加事件处理程序的主要好处是可以添加多个事件处理程序。 // 这两个事件处理程序会按照添加它们的顺序触发，因此首先会显示元素的ID，其次会显示\" Hello world!\" 消息。 var btn=document.getElementById(\"myBtn\"); btn.addEventListener(\"click\",function(){ alert(\"this.id\") },false); btn.addEventListener(\"click\",function(){ alert(\"Hello World！\") },false); removeEventListener() 删除事件处理程序 // 下面这个函数，虽然看起来合乎逻辑， // 但是removeEventListener清除的程序与addEventListener绑定的事件不是同一个 var btn=document.getElementById(\"myBtn\"); btn.addEventListener(\"click\",function(){ alert(\"Hello World！\") },false); btn.removeEventListener(\"click\",function(){ alert(\"Hello World!\"); }) // 我们在这里用另一个例子来表现,这个例子中绑定事件程序与删除事件程序使用了相同的函数 var btn=document.getElementById(\"myBtn\"); var handler = function () { alert(this.id); } btn.addEventListener(\"click\",handler,false); btn.removeEventListener(\"click\",handler,false); 建议 大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。如果不是特别需要，我们不建议在事件捕获阶段注册事件处理程序。 IE事件处理程序 IE实现了与DOM中类似的两个方法：attachEvent()和detachEvent()。这两个方法接受相同的两个参数：事件处理程序名称与事件处理程序函数。由于IE8及更早版本只支持事件冒泡，所以通过attachEvent()添加的事件处理程序都会被添加到冒泡阶段。 attachEvent() /* 下面这个例子中 事件绑定 时 ,第一个参数用的是 onclick， IE使用attachEvent()与使用DOM0方法的主要区别在于处理程序的作用域。*/ var btn=document.getElementById(\"MyBtn\"); btn.attachEvent(\"onclick\",function(){ alert(\"Clicked\"); }) /* 在DOM0级方法的情况下，事件处理程序会在其所属元素的作用域内运行； 在使用attachEvent()方法的情况下，事件处理程序会在 全局作用域中运行， 因此this等于windows。 */ var btn =document.getElementById(\"myBtn\"); btn.attachEvent(\"onclick\",function(){ alert(this===window);//true }) // 添加多个元素的方法 var btn = document.getElementById(\"myBtn\"); var handler=function (){ alert(\"Hello World!\") } var hello=function (){ alert(\"hello\"); } btn.attachEvent(\"onclick\",handler); btn.attachEvent(\"onclick\",hello); // 执行顺序:多事件绑定，执行顺序是以倒序的方式执行的。 // hello // Hello World! detachEvent() // 移除attachEvent添加的事件处理程序程序 var btn = document.getElementById(\"myBtn\"); var handler = function () { alert('Clicked'); } btn.attachEvent(\"onclick\",handler); btn.detachEvent(\"onclick\",handler); 跨浏览器的事件处理程序 addHandler()|removeHandler() 这2个方法属于一个名叫EventUtil的对象 参数：要操作的元素 | 事件名称 | 事件处理接受程序 /* 解析：首先判断是否存在DOM2级方法，如果存在==>传入事件类型， 事件处理程序函数，和第三个参数方法false（表示冒泡阶段）， 如果存在的是IE的方法，就采用第二种方法，为了兼容IE8及跟早的版本， 此时的时间类型必须加上\"on\"前缀。 最后一种是DOm0级方法(现代浏览器，一般不会执行这里的代码)， 使用方括号语法将属性名指定为事件处理程序或者将属性设置为null；*/ var EventUtil={ addHandler:function(element,type,handler){ if(element.addEventListener){ element.addEventListener(type,handler,false); }else if(element.attachEvent){ element.attachEvent(\"on\" + type,handler); }else { element[\"on\" + type] = handler; } }, removeHandler:function(element,type,handler){ if(element.removeEventListener){ element.removeEventListener(element,type,false); }else if(element.detachEvent){ element.detachEvent(\"on\"+type,handler); }else{ element[\"on\"+type]=null; } } } // 实例：使用EventUtil对象==>绑定click事件并删除click事件 // 分析：由于addHandler和removeHandler没有考虑到所有浏览器的问题， // 例如IE浏览器中的作用域的问题，所以我们往往只用作添加处理程序或者移除处理程序。 //提示：只DoM0级的浏览器已经不多了，所以需要注意的问题不是很多 var btn = document.getElementById(\"myBtn\"); var handler = function (){ alert(\"你好！\"); } EventUtil.addHandler(btn,\"click\",handler); EventUtil.removeHandler(btn,\"click\",handler); "},"JavaScript/cases/":{"url":"JavaScript/cases/","title":"案例解析","keywords":"","body":"案例收集 "},"JavaScript/cases/0.html":{"url":"JavaScript/cases/0.html","title":"动态替换图片","keywords":"","body":"动态替换图片 目的： 在制作个人网站的时候，我需要在header里面加入各大社交网站的直链，可以让更多人，找到我，提供他们的想法。并且去实现那个想法。 展现方式： 是以一种点击图标的的形式，展示不同社交网站的二维码或者是链接。在开发过程中遇到很多有意思的坑，想分享给大家，希望可以给看到本文的小伙伴提供点帮助。 使用技巧 由于在一开始，我们就用了多个程序来进行区分不同事件点击之后，显示不同的图片的功能。但是在一段时间之后发现这样子的代码谈不上什么有价值的，所以我重新花了点时间，把代码重新架构了一番。清理了冗余代码，同时也把程序优化了。 优化之后的程序只要将植入代码，就可以实现简单的点击不同按钮,相同位置展示不同图片功能。 项目结构： ├──index // 示例 index │ ├──js │ │ └──index.js │ ├──css │ │ └──index.js index.html详解 首先页面header排版，设置具体结构 ├── div // 示例 header │ ├── div │ │ └── img │ │ └── img │ │ └── img 在每个img中添加onclick=\"hImage()\"属性，并给每个\"hImage()\"中加入\"1-3\"值；设置这个值，是为了在index.js的hImage()函数中做出对应的判断。 模态框 ├── div // 示例 模态框 │ ├── div │ │ └── div │ │ └── img │ │ └── h1 第一层div设置模态框显示之后的透明色背景。 第二层div主要是做模态框显示之后的内容的框架 第二层div下面的div是关闭模态框按钮。里面加入 onclick=\"hShow()\" 函数，该函数负责关闭模态框 × 第二层div下面的 img 则是展示不同图标点击之后，显示的二维码 第二层div下面的 h1 则是展示不同图标点击之后，显示的提示信息 这里的模态框设置 使用position中的fixed，来设置模态框的位置与样式。同 × index.js详解 var hModule = document.getElementsByClassName('h-module');//获取模态框中的关闭按钮属性 var hhtImg = document.getElementById(\"hhtImg\");//设置模态框不同位置按钮点击之后展示的属性图片属性 var hText=document.getElementById(\"hText\");//设置模态框显示之后的提示信息 /*hImage函数 * 由于图片只有一张，所以同时设置title属性以示区分 * 通过 switch语句判断点击不同按钮， * 在模态框展示不同的图片。 */ function hImage(e) { console.log(); switch (e) { case 1: //hhtImg.src为设置需要展示的图片的地址 hhtImg.src = \"http://oigzh9iic.bkt.clouddn.com/%E4%BA%AB%E6%9C%88%E4%BC%9A%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg\"; hhtImg.title = \"这里是\" + e;//此处设置鼠标悬浮于图片时显示的文字 hText.innerHTML=\"这里是二维码\" + e;//此出设置模态框显示之后，展示提示文字的内容 break; case 2: hhtImg.src = \"http://oigzh9iic.bkt.clouddn.com/%E4%BA%AB%E6%9C%88%E4%BC%9A%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg\"; hhtImg.title = \"这里是\" + e; hText.innerHTML=\"这里是二维码\" + e; break; case 3: hhtImg.src = \"http://oigzh9iic.bkt.clouddn.com/%E4%BA%AB%E6%9C%88%E4%BC%9A%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg\"; hhtImg.title = \"这里是\" + e; hText.innerHTML=\"这里是二维码\" + e; break; } hModule[0].style.display = \"block\"; } /*hShow函数 * 功能：关闭模态框； * 由于原生js中，获取参数的值 * 之后，其属性为数组形式； * 需要设置下标，再去设置style属性， * 或者是其他属性 * */ function hShow() { hModule[0].style.display = \"none\"; } "},"JavaScript/cases/01.html":{"url":"JavaScript/cases/01.html","title":"原生Ajax学习","keywords":"","body":"原生Ajax学习 示例 这里先展示一个比较复杂的应用写法，原理什么的看下面介绍。 注意，本例是学习笔记，学习地址 源码 document.getElementById(\"save\").onclick = function() { var request = new XMLHttpRequest(); request.open(\"POST\", \"server.php\"); var data = \"name=\" + document.getElementById(\"staffName\").value + \"&number=\" + document.getElementById(\"staffNumber\").value + \"&sex=\" + document.getElementById(\"staffSex\").value + \"&job=\" + document.getElementById(\"staffJob\").value; request.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); request.send(data); request.onreadystatechange = function() { if (request.readyState===4) { if (request.status===200) { document.getElementById(\"createResult\").innerHTML = request.responseText; } else { alert(\"发生错误：\" + request.status); } } } } Ajax 其实原理很简单的。就是调用 XMLHttpRequest 对象来实现前端与后台的数据通信！ 第一步：实例化 XMLHttpRequest 对象 var request = new XMLHttpRequest(); 第二步：调用 open() 方法 open(Method[数据传输方法: POST | GET ], URL , async[true（异步）| false（同步）] ); request.open(\"GET\", \"server.php?number=\" + document.getElementById(\"keyword\").value); 第三步：调用 setRequestHeader 这里已经有人把 setRequestHeader 内容很详细的介绍一遍了，这里就不做太多的解释。传送门 request.open(\"GET\", \"server.php?number=\" + document.getElementById(\"keyword\").value); 第四步：调用 send() 方法 send方法接受一个参数，作为请求主体发送的数据。 注意:如果没有参数，则必须填写 null request.send(参数|null) 由于send的请求是同步的，请求得到服务器响应之后。响应的数据会自动填充XHR对象的属性 console.log(request.responseText);//响应主体被返回的文本 console.log(request.responseXML);//与 responseText 以字符串返回 HTTP 响应不同，responseXML 以 XML 返回响应。ResponseXML 属性返回 XML 文档对象，可使用 W3C DOM 节点树的方法和属性来检查和解析该对象。 request.status Ajax status和statusText状态对照表 0：未初始化。尚未调用open()方法。 1：启动。已调用open()方法,但尚未调用send()方法。 2：发生。已调用send()方法，但尚未接收到响应。 3：接受。已经接收到部分响应数据。 4：完成。已经接收到响应数据，并且可以在客户端使用。 console.log(request.status);//响应的HTTP状态 console.log(request.statusText);//HTTP状态的说明 第五步：调用 onreadystatechange 事件处理程序 request.onreadystatechange     当请求被发送到服务器时，我们需要执行一些基于响应的任务。     每当 readyState 改变时，就会触发 onreadystatechange 事件。     readyState 属性存有 XMLHttpRequest 的状态信息。 如下所示：我们通过if语句判断 request.readyState 的响应数据，进行数据处理。 request.onreadystatechange = function () { if (request.readyState === 4) { console.log(request.readyState); if (request.status === 200) { document.getElementById(\"createResult\").innerHTML = request.responseText; } else { alert(\"发生错误：\" + request.status); } } } "},"JavaScript/cases/02.html":{"url":"JavaScript/cases/02.html","title":"React/React Native 的ES5 ES6写法对照表","keywords":"","body":"React/React Native 的ES5 ES6写法对照表 来源： React on ES6+React/React Native 的ES5 ES6写法对照表 class定义语法 值得注意的是，我们已经删除了两个括号和一个后缀分号，而对于每个声明的方法，我们都省略了一个冒号，一个function关键字和一个逗号。 class Photo extends React.Component { render() { return } } // The ES5 way var Photo = React.createClass({ handleDoubleTap: function(e) { ... } render: function() { ... } }) //ThE ES6 way class Photo extends React.Component { handleDoubleTap(e) { ... } render() { ... } } 生命周期方法 所有的生命周期方法，但可以定义为使用新的类语法期望的。该课程constructor现在承担以前填写的角色componentWillMount： // es5 var EmbedModal = React.createClass({ componentWillMount: function() { ... } }) // es6 class EmbedModal extends React.createClass ( construtor(props) { super(props); // Operations usually carried out in componentWillMount go here } ) 属性初始化 ES7属性初始化器在类的构造函数中运行，其中this指的是正在构建的类的实例，所以初始状态仍然可以依赖于this.props。值得注意的是，我们不再需要根据吸气功能定义道具默认值和初始状态对象。 // es5 var Video = React.createClass({ getDefaultProps: function() { return { autoPlay: flase, maxLoops: 10, }; }, getInitalState: function() { return { loopsRemaining: this.props.maxloops, }; }, propsTypes: { autoPlay: React.PropsTypes.bool.isRequired, maxloops: React.PropsTypes.number.isRequired, posterFrameSrc: React.PropsTypes.string.isRequired, videoSrc: React.PropsTypes.string.isRequired }, }); // es6 class Video extends React.Component { static defaultProps = { autoPlay: false, maxloops: 10 } static propsTypes = { autoPlay: React.PropsTypes.bool.isRequired, maxloops: React.propsTypes.number.isRequired, posterFrameSrc: React.PropsTypes.string.isRequired, videoSrc: React.PropsTypes.string.isRequired } state = { loopsRemaining: this.props.maxloops, } } 箭头函数说明 该React.createClass方法用于对组件的实例方法执行一些额外的绑定工作，以确保其中的this关键字将引用该组件的实例。 // 自动绑定React.createClass var PostInfo = React.createClass({ handleOptionsButtonClick: function(e) { // 这里，'this' 是指组件实例。 this.setState({showOptionModal: true}); }, }); 由于我们React.createClass在使用ES6 +类语法定义组件时不涉及该方法，所以我们需要手动绑定实例方法，无论我们想要这种行为： // 手动绑定，无论你是否需要 class PostInfo extends React.Component { construtor(props) { super(props); // 手动将此方法绑定到组件实例中… this.handleOptionsButtonClick = this.handleOptionsButtonClick.bind(this); } handleOptionsButtonClick(e) { // …为了确保'this'指的是组件实例。 this.setState({showOptionsModal: true}); } } 幸运的是，通过组合两个ES6 +功能 - 箭头函数和属性初始值设置 - 选择加入到组件实例的绑定变得轻而易举： class PostInfo extends React.Component { handleOptionsButtonClick = (e) => { this.setState({showOptionsModal: true}); } } ES6箭头函数的主体具有与它们周围this的代码相同的词汇，这使得我们获得了期望的结果，因为ES7属性初始化器的作用域的方式。在罩下看，看看为什么这个工作。 动态属性名称和模板字符串 其中的增强对象文本包括分配给派生属性名称的能力。我们原本可以做这样的事情来设定一个状态： ```js var From = React.createClass({ onChange: function(inputName, e) { var stateToSet = {}; stateToSet[inputName + 'Value'] = e.targe.value; this.setState(stateToset); }, }); // 现在，我们有能力构建在运行时由JavaScript表达式决定其属性名称的对象。在这里，我们使用模板字符串来确定要设置的属性： class From extends React.Component { onChange(inpuntName, e){ this.setState({ [`$(inputName)value`]: e.targe.value, }); } } ## 解构和传播属性 >通常在组成组件时，我们可能希望将大部分父组件的道具传递给子组件，但并不是全部。将ES6 + 解构与JSX 传播属性相结合，无需仪式即可实现： ```js class AutoloadingPostsGrid extends React.Component { render() { const { className, ...others // 包含所有特性this.props除了类名 } = this.props; return ( Load more ); } } // 我们可以将JSX传播属性与常规属性结合起来，利用简单的优先级规则来实现覆盖和默认值。该元素将获得className“覆盖”，即使存在一个className财产this.props： ... // This element will regularly have the “base” unless there exists a property in to override it: ... 模块 // 引用 // es5 var React = require(\"react\"); var { Component, PropsTypes } = React; //引用react抽象组件 var ReactNative = require(\"react-native\"); var { Image, Text, } = ReactNative; // 引用具体的React Native组件 // es6 import写法更为标准 import React, { Component, PropsTypes, } from 'react'; import { imange， Text, } from 'react-native' 导出单个类 在ES5里，要导出一个类给别的模块用，一般通过module.exports来导出 // es5 var MyComponent = React.createClass({ // 函数 }) // es6 export default class MyComponent extends Component{ // 函数 } // 引用 class // es5 var MyComponent = require(('./MyComponent')); // es6 import MyComponent from './MyComponent'; 定义组件 es5 在ES5里，通常通过React.createClass来定义一个组件类，像这样： var Photo = React.createClass({ render: function() { return ( ) } }) 在ES6里，我们通过定义一个继承自React.Component的class来定义一个组件类，像这样： class Photo extends React.Component { render() { return ( ); } } 给组件定义方法 给组件定义方法不再用 名字: function()的写法，而是直接用名字()，在方法的最后也不能有逗号了。 // es5 var Photo = React.createClass({ componentWillMount: function() { // 函数 }, render: function() { return ( ); }, }); // es6 class Photo extends React.Component { componentWillMount() { // 函数 }, render() { return ( ); } } 定义组件的属性类型和默认属性 在ES5里，属性类型和默认属性分别通过propTypes成员和getDefaultProps方法来实现 // es5 var video = React.createClass({ getDefaultProps: function() { return { autoPlay: false, maxloops: 10, }; }, PropsTypes: { autoPlay: React.PropsTypes.bool.isRequired, maxloops: React.PropsTypes.number.isRequired, posterFrameSrc: React.PropsTypes.string.isRequired, videoSrc: React.PropsTypes.string.isRequired, }, render: function() { return: function() { }; } }) 在ES6里，可以统一使用static成员来实现 //es6 class Video extends React.Component { static defaultProps = { autoPlay: flase, maxloops: 10, }; // 注意这里有分号 static propsTypes = { autoPlay: React.PropsTypes.bool.isRequired, maxloops: React.PropsTypes.number.isRequired, posterFrameSrc: React.PropsTypes.string.isRequired, videoSrc: React.PropsTypes.string.isRequired, }; // 注意这里有分号 render() { return ( ) } } 也有人这么写，虽然不推荐，但读到代码的时候你应当能明白它的意思： //es6 class Videlo extends React.Component { render() { return ( ); } } Video.defauleftProps = { autoPlay: false, maxloops: 10, }; Video.propsTypes = { autoPlay: React.PropsTypes.bool.isRequired, maxloops: React.PropsTypes.number.isRequired, posterFrameSrc: React.PropsTypes.string.isRequired, videoSrc: React.PropsTypes.string.isRequired, } // 注意: 对React开发者而言，static成员在IE10及之前版本不能被继承，而在IE11和其它浏览器上可以，这有时候会带来一些问题。React Native开发者可以不用担心这个问题。 初始化STATE // es5 var video = React.createClass({ getInitalState: function() { return { loopsRemaining: this.props.maxloops, }; } }) // ES6下，有两种写法： class Video extends React.Component { state = { loopsRemaining: this.props.maxloops, } } // 不过我们推荐更易理解的在构造函数中初始化（这样你还可以根据需要做一些计算）： // es6 class Video extends React.Component { construtor(props){ super(props); this.state = { loopsRemaining: this.props.maxloops, } } } 把方法作为回调提供 很多习惯于ES6的用户反而不理解在ES5下可以这么做： var PostInfo = React.createClass({ handleOptionsButtonClick: function(e) { // Here,'this' refers to the component instance this.setState({showOptionModel: true}); }, render: function() { return ( {this.props.label} ) }, }); 在ES5下，React.createClass会把所有的方法都bind一遍，这样可以提交到任意的地方作为回调函数，而this不会变化。但官方现在逐步认为这反而是不标准、不易理解的。 在ES6下，你需要通过bind来绑定this引用，或者使用箭头函数（它会绑定当前scope的this引用）来调用 // es6 class PostInfo extends React.Component { handleOptionsButtonClick(e){ this.setState({showOptionsModal: true}); } render() { return ( this.handleOptionsButtonClick(e)} > {this.props.label} ) }, } 箭头函数 箭头函数实际上是在这里定义了一个临时的函数，箭头函数的箭头=>之前是一个空括号、单个的参数名、或用括号括起的多个参数名，而箭头之后可以是一个表达式（作为函数的返回值），或者是用花括号括起的函数体（需要自行通过return来返回值，否则返回的是undefined）。 // 箭头函数实例 ()=>1 v=>v+1 (a,b)=>a+b ()=>{ alert('foo'); } e=>{ if (e == 0){ return 0; } return 1000/e; } 需要注意的是，不论是bind还是箭头函数，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做一些别的事情（譬如卸载监听器），那么你必须自己保存这个引用 // 错误的做法 class PaussMenu extends React.Component{ componentWillMount() { AppStateIOS.addEventListener('change', this.onAppPaused.bind(this)); } componentDidUnmount() { AppStateIOS.removeEventListener('change', this.onAppPaused.buid(this)); } onAppPaused(event){ } } // 正确的做法 class PaussMenu extends React.Component{ construtor(props) { super(props); this._OnAppPaused = this.onAppPaused.bind(this); } componentWillMount() { AppStateIOS.addEventListener('change', this._OnAppPaused); } componentDidUnmount() { AppStateIOS.removeEventListener('change', this_onAppPaused); } onAppPaused(event) { } } // 从这个帖子[这个帖子](http://www.tuicool.com/articles/Rj6RFnm)中我们还学习到一种新的做法： // 正确的做法 class PaussMenu extends React.createClass{ componentWillMount() { AppStateIOS.addEventListener('change', this.onAppPaused); } componentDidUnmount() { AppStateIOS.removeEventListener('change', this.onAppPaused); } onAppPaused = (event) => { // 把方法直接作为一个arrow function的属性来定义，初始化的时候就绑定好了this的指针 } } Mixins 在ES5下，我们经常使用minxin来为我们的类添加一些新的方法，譬如PureRenderMinxin ``` var PurRenderMixin = require('react-addins-pure-render-minxin'); React.createClass({ mixin: [PurRenderMixin], render: function() { return foo; } }) > 然而现在官方已经不再打算在ES6里继续推行Mixin，他们说：Mixins Are Dead. Long Live Composition。 尽管如果要继续使用mixin，还是有一些第三方的方案可以用，譬如这个方案 不过官方推荐，对于库编写者而言，应当尽快放弃Mixin的编写方式，文中提到Sebastian Markbåge的一段代码推荐了一种新的编码方式： //Enhance.js import { Component } from 'React' extends var Enhance = ComposedComponent => class extends Component { construtor() { this.state = {dtaa:null} } componentDidUnmount() { this.setState({ data: 'Hello' }); } render() { renturn } } // HigherOrderComponent.js import { Enhance } from \"./Enhance\"; class MyComponent { render() { if (!this.data) return Waiting...; return {this.data}; } } export defaule Enhance(MyComponent); // Enhance component //用一个“增强函数”，来某个类增加一些方法，并且返回一个新类，这无疑能实现mixin所实现的大部分需求。 ## ES6+带来的其它好处 ### 解构&属性延展 > 结合使用ES6+的解构和属性延展，我们给孩子传递一批属性更为方便了。这个例子把className以外的所有属性传递给div标签： class AutoloadingPostsGrid extends React.Component { render() { var { className, ...others, } = this.props; return ( Load more ); } } > 下面这种写法，则是传递所有属性的同时，用覆盖新的className值： ... > 这个例子则相反，如果属性中没有包含className，则提供默认的值，而如果属性中已经包含了，则使用属性中的值 ... ``` "},"JavaScript/cases/03.html":{"url":"JavaScript/cases/03.html","title":"战舰游戏","keywords":"","body":"战舰游戏 输入 * { margin: 0; padding: 0; } body{ background-color: black; } .continuar { margin: 0; /*width: 100%;*/ width: 650px; position: relative; height: 650px; background: url('../images/board.jpg') no-repeat; background-size: contain; /* background-color: rgba(37, 17, 17, 0.849); */ } table { margin: 0 auto; /*padding-top: 9%;*/ padding-top: 62px; } tr td { width: 60px; height: 60px; border: 0px solid rgb(21, 172, 16); } td.ship{ background: url('../images/ship.png') no-repeat; background-size: contain; background-position: center; } td.miss{ background: url('../images/miss.png') no-repeat; background-size: contain; background-position: center; } .enter{ position: absolute; right: 14%; bottom:0; display: flex; padding: 20px; } .enter input { height: 35px; color: #000000; background-color: rgb(159, 255, 48); display: block; float: left; border:0; } .enter .btn{ height: 25px; float: left; padding: 0 5px; cursor:pointer; font-size: 12px; color: aliceblue; margin-left: 5px; line-height: 25px; user-select: none; text-align: center; background-color: #41510d; border:5px solid #46e234; } window.onload = function () { let btnEnter = document.getElementById('btnEnter'); let coordinate = document.getElementById('coordinate'); // 给节点添加点击事件 btnEnter.onclick = btn; coordinate.onkeypress = key; function key(e) { // 监听`enter`键是否被点击 if (e.charCode === 13) { btn() } } // 转化坐标 let digital = {'A': 0, 'B': 7, 'C': 14, 'D': 21, 'E': 28, 'F': 35, 'G': 42}; // 使用随机数,初始化战舰位置 let ships = {0: Math.floor(Math.random() * 48), 1: Math.floor(Math.random() * 48), 2: Math.floor(Math.random() * 48)}; console.log(ships); // 获取所有的`td` function btn() { console.log(coordinate.value); let patt1 = new RegExp(/^[a-g][0-6]/i); if (patt1.test(coordinate.value)) { // 截取字符串中的首位,将其转化为大写字母 let coordinateText = coordinate.value[0].toUpperCase(); // 玩家输入的战舰坐标 let coordinateNumber = Number.parseInt(digital[coordinateText]) + Number.parseInt(coordinate.value[1]); // 获取所有名为 `td` 的节点 let tds = document.getElementsByTagName('td'); // 判断玩家输入的坐标上,是否有战舰存在,如果有的话,就击沉战舰 if (ships[0] === coordinateNumber || ships[1] === coordinateNumber || ships[2] === coordinateNumber) { // 击沉战舰 tds[coordinateNumber].setAttribute('class', 'ship'); } else { // 没有击沉战舰 tds[coordinateNumber].setAttribute('class', 'miss'); } } else { alert('请输入正确的坐标;\\n如: A6!') } } }; "},"JavaScript/cases/04.html":{"url":"JavaScript/cases/04.html","title":"正则截取指定字符串","keywords":"","body":"正则截取指定字符串 参考文章 正则截取指定字符串 let str='{\"asd\":\\\\1234\\\\1234\\\\1234\\\\1234,\"true\"}, {\"sada\":\\\\1111\\\\1234\\\\1234\\\\4444,\"true\"}'; let substr = str.match(/\"sada\":(\\S*),\"true\"/); console.log(substr[1]); // \\\\1111\\\\1234\\\\1234\\\\4444 "},"JavaScript/cases/05.html":{"url":"JavaScript/cases/05.html","title":"常用功能收集","keywords":"","body":"常用功能收集 浏览器基本信息判断 /* * 智能机浏览器版本信息: * */ var browser = { versions: function () { var u = navigator.userAgent, app = navigator.appVersion; console.log(u); return {//移动终端浏览器版本信息 trident: u.indexOf('Trident') > -1, //IE内核 presto: u.indexOf('Presto') > -1, //opera内核 webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核 gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核 mobile: !!u.match(/Mobile/g), //去掉浏览器内核判断 // mobile: !!u.match(/AppleWebKit.*Mobile.*/) || !!u.match(/AppleWebKit/), //是否为移动终端 ios: !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器 iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者QQHD浏览器 iPad: u.indexOf('iPad') > -1, //是否iPad webApp: u.indexOf('Safari') == -1 //是否web应该程序，没有头部与底部 }; }(), language: (navigator.browserLanguage || navigator.language).toLowerCase() } document.writeln(\"语言版本: \" + browser.language); document.writeln(\" 是否为移动终端: \" + browser.versions.mobile); document.writeln(\" 是否为webKit: \" + browser.versions.webKit); document.writeln(\" ios终端: \" + browser.versions.ios); document.writeln(\" android终端: \" + browser.versions.android); document.writeln(\" 是否为iPhone: \" + browser.versions.iPhone); document.writeln(\" 是否iPad: \" + browser.versions.iPad); document.writeln(navigator.userAgent); JavaScript|jQuery判断元素即将出现在文档可视区域或文档可视区域的顶部 /* JavaScript判断元素即将出现在文档可视区域或离开文档可视区域. 一、判断元素是否处于可视文档区域顶部 判断条件:DOMTop.offsetTop + clientHeight - 10 导航条动画，设定 function navAnimation() { let DOMTop = document.getElementById('nav'), // 获取导航对象 clientHeight = document.documentElement.clientHeight, // 获取窗口可视区域高度 tru = true, // 是否替换类名的依据 clientHeightScrollTop = clientHeight + DOMTop.offsetTop + DOMTop.clientHeight; // 是否替换类名的依据 // 监听文档滚动条事件，绑定动画 document.addEventListener('scroll', function () { let scrollTop = null; if (document.body.scrollTop !== 0) { scrollTop = document.body.scrollTop } else { scrollTop = document.documentElement.scrollTop } if (tru && clientHeightScrollTop clientHeight + scrollTop) { DOMTop.setAttribute('class', 'page-nav'); tru = true } }, false); } 锚链接跳转过渡 /* # 锚链接跳转过度 条件： 1.目标位置 & 滚动条位置 距离过近 2.目标位置 > 滚动条位置 3.目标位置 21) { let scrollInterval = setInterval(function () { if (s 文章标题的动画 function animateIn() { let animateIn = document.querySelectorAll('.container .title strong'); // console.log(animateIn.getAttribute('class')) // console.log(animateIn) let that = null; for (let i = 0; i "},"angular/study_notes/":{"url":"angular/study_notes/","title":"Study notes","keywords":"","body":"说明 angular权威教程学习笔记 源码 "},"angular/study_notes/0_depend.html":{"url":"angular/study_notes/0_depend.html","title":"项目依赖","keywords":"","body":"app.moduel.ts // 导入依赖库 import {BrowserModule} from '@angular/platform-browser'; import {NgModule} from '@angular/core'; import {FormsModule,ReactiveFormsModule} from '@angular/forms'; // 组件来源 import {AppComponent} from './app.component'; import {HeroFromComponent} from './hero-from/hero-from.component'; import {SukComponent} from './suk/suk.component'; import { FormcontrolComponent } from './formcontrol/formcontrol.component'; import { FormBuilderComponent } from './form-builder/form-builder.component'; import { EventEmitterComponent } from './event-emitter/event-emitter.component'; import { NgModelComponent } from './ng-model/ng-model.component'; import { OkComponent } from './ok/ok.component'; // 注入 @NgModule({ // 注册组件 declarations: [ AppComponent, HeroFromComponent, SukComponent, FormcontrolComponent, FormBuilderComponent, EventEmitterComponent, NgModelComponent, OkComponent ], // 引入依赖库 imports: [ BrowserModule, FormsModule, ReactiveFormsModule ], providers: [], // 引导组件 bootstrap: [AppComponent] }) export class AppModule { } "},"angular/study_notes/01_built-in_instructions.html":{"url":"angular/study_notes/01_built-in_instructions.html","title":"内置指令","keywords":"","body":"ngIf 如果你希望根据一个条件来决定显示或隐藏一个元素,可以使用 ngIf 指令。这个条件是由你传给指令的表达式的结果决定的。 如果表达式的结果返回的是一个假值,那么元素会从DOM上被移除。 # 例子： b\" > ngSwitch ** 实际作用同等于 switch语句 # 通过2组实例进行比较 ## ngIf 根据同值不同条件渲染不同元素 Var is A Var is B Var is something else 增加条件与值 Var is A Var is B Var is C Var is something else ### ngSwitch 改变上述情况，官方加入 ngSwitch 使用 ngSwitchCase 指令描述已知结果 使用 ngSwitchDefault 指令处理所有其他未知情况 重写实例 Var is A Var is B Var is something else 添加条件： ngSwitchDefault 元素是可选的。如果我们不用它,那么当 myVar 没有匹配到任何期望的值 时就不会渲染任何东西。 Var is A Var is B Var is C Var is something else 为不同的元素声明同样的 *ngSwitchCase 值 在下面的例子中,当 choice 的值是 2 的时候,第2个和第5个 li 都会被渲染。 Current choice is {{ choice }} First choice Second choice Third choice Fourth choice Second choice, again Default choice Next choice ngStyle 第一种用法：使用 ngStyle 指令,可以通过Angular表达式给特定的DOM元素设定CSS属性。 该指令最简单的用法就是 [style.]=\"value\" 的形式, Uses fixed yellow background 第二种用法：设置固定值的方式就是使用 ngStyle 属性,使用键值对来设置每个属性 Uses fixed white text on blue background 第三种用法：这个才是ngStyle的出彩的地方 Apply setting {{ color }} text {{ color }} background // 定义数据类型，定义触发事件 export class InventoryAppComponent implements OnInit { color:string; fontSize:number; apply(color: string, fontSize: number) { this.color = color; this.fontSize = fontSize; } constructor() { } ngOnInit() { } } ngClass ngClass 指令在HTML模板中用 ngClass 属性来表示,让你能动态设置和改变一个给定DOM元素的CSS类。 以下是最简单的用法。 .bordered { border: 1px dashed black; background-color: #eee; } This is never bordered This is always bordered 动态添加class Using object var. Border `{{ classesObj.bordered ? \"ON\" : \"OFF\" }}` Using object literal. Border `{{ isBordered ? \"ON\" : \"OFF\" }}` This will always have a blue background and round corners This is { { classList.indexOf('blue') > -1 ? \"\" : \"NOT\"}} blue and { { classList.indexOf('round') > 1 ? \"\" :\"NOT\" }} round // 定义数据，并赋值 export class InventoryAppComponent implements OnInit { isBordered: boolean; classesObj: Object; classList: string[]; constructor() { this.isBordered = true; this.classesObj = { bordered : \"bordered\" }; this.classList = ['blue', 'round']; console.log(this) } ngOnInit() { } } ngFor 这个指令的任务是重复一个给定的DOM元素 (或一组DOM元素),每次重复都会从数组中取 一个不同的值。 它的语法是 *ngFor=\"let item of items\" 。 简化版 cities: string[]; constructor() { this.cities = ['Miami', 'Sao Paulo', 'New York']; } Simple list of strings {{ c }} Miami Sao Paulo New York 进阶版 people: Object[]; constructor() { this.people = [ { name: 'Anderson', age: 35, city: 'Sao Paulo' }, { name: 'John', age: 12, city: 'Miami' }, { name: 'Peter', age: 22, city: 'New York' } ]; } table List of objects Name Age City {{ p.name }} {{ p.age }} {{ p.city }} 输出 Name Age City Anderson 35 Sao Paulo John 12 Miami Peter 22 New York 嵌套数组 Nested data {{ item.city }} Name Age {{ p.name }} {{ p.age }} peopleByCity: Object; constructor() { this.peopleByCity = [ { city: 'Miami', people: [ { name: 'John', age: 12 }, { name: 'Angel', age: 22 } ] }, { city: 'Sao Paulo', people: [ { name: 'Anderson', age: 35 }, { name: 'Felipe', age: 36 } ] } ]; } 输出 Miami Name Age John 12 Angel 22 输出 Sao Paulo Name Age Anderson 35 Felipe 36 获取索引 {{ num+1 }} - {{ c }} 1-Miami 2-Sao Paulo 3-New York ngNonBindable 当我们想告诉Angular不要编译或者绑定页面中的某个特殊部分时,要使用 ngNodBindable指令。 {{content}} &larr;This is what {{ content }} rendered 输出 文章 ←This is what {{ content }} rendered "},"angular/study_notes/from/":{"url":"angular/study_notes/from/","title":"表单","keywords":"","body":"表单 "},"angular/study_notes/from/0_template_case.html":{"url":"angular/study_notes/from/0_template_case.html","title":"模板案例","keywords":"","body":"表单——既重要,又复杂 　实例展示 以下实例来着angular官网以下例子通过数据绑定与内置模板的集成，编写而来。 Hero Form Name Name is required Alter Ego Hero Power {{pow}} Power is required Submit New Hero You submitted the following: Name {{ model.name }} Alter Ego {{ model.alterEgo }} Power {{ model.power }} Edit /*hero-from.component.css*/ .ng-valid[required], .ng-valid.required { border-left: 5px solid #42A948; /* green */ } .ng-invalid:not(form) { border-left: 5px solid #a94442; /* red */ } // app.module.ts import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { FormsModule } from '@angular/forms'; import { AppComponent } from './app.component'; import { HeroFromComponent } from './hero-from/hero-from.component'; @NgModule({ declarations: [ AppComponent, HeroFromComponent ], imports: [ BrowserModule, FormsModule ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } // hero-from.component.ts import {Component, OnInit} from '@angular/core'; import {Hero} from './Hero' @Component({ selector: 'hero-from', templateUrl: './hero-from.component.html', styleUrls: ['./hero-from.component.css'] }) export class HeroFromComponent implements OnInit { powers = ['Really Smart', 'Super Flexible', 'Super Hot', 'Weather Changer']; model = new Hero(18, 'Dr IQ', this.powers[0], 'Chuck Overstreet'); submitted = false; onSubmit() { this.submitted = true; } // TODO: Remove this when we're done get diagnostic() { return JSON.stringify(this.model); } ngOnInit() { } } // Hero.ts 定义数据类型 export class Hero { constructor(public id: number, public name: string, public power: string, public alterEgo?: string) { } } 　实例解析 该例，使用ngModel ,绑定数据，并通过　valid pristine　判断input是否有输入。最后用submitted控制表单模拟提交事件 html代码解析: 绑定ng内置froms模板:方法 => #heroForm=\"ngForm\" 为表单元素绑定ngModule: 展示ngModel : 方法　=> {{ model.name }} 判断表单内容是否输入 Name is required 控制组件是否显示: 方法 => [hidden]=\"!submitted\" submitted为变量，受事件驱动 "},"angular/study_notes/from/01_formControl.html":{"url":"angular/study_notes/from/01_formControl.html","title":"formControl","keywords":"","body":"表单——既重要,又复杂 FormControl 代表单一的输入字段,它是Angular表单中的最小单元。FormControl 封装了这些字段的值和状态,比如是否有效、是否脏(被修改过)或是否有错误等。 app.module.ts 见Angular说明 说明 #myForm=\"ngForm\" 绑定 ngForm指令,该指令来自 NgForm,在这里的意思是 为当前视图中的ngForm创建一个别名,并且绑定到变量 #myForm上去. ngForm 是 FormGroup 类型的对象 (ngSubmit)=\"OS(myForm.value)\" (ngSubmit) : 表单提交点击事件;OS : 为事件名称;(myForm.value) : 则是将变量myForm的value值传给OS函数 [(ngModel)]=\"name\" 见angular2_表单_ngModel中的说明 name: string; myForm: FormGroup; 定义变量类型 HTML Demo Form: Sku SKU {{name}} Submit TS import {Component, OnInit} from '@angular/core'; import {FormControl, FormGroup, Validator} from \"@angular/forms\" @Component({ selector: 'form-control', templateUrl: './formcontrol.component.html', styleUrls: ['./formcontrol.component.css'] }) export class FormcontrolComponent implements OnInit { name: string; myForm: FormGroup; constructor() { } // 点击事件 /* :void 表示可以传入任意参数到函数中*/ OS(value: any):void { console.log('你的提交值', value); } // ngOnInit(): void { this.nameForm = new FormGroup({ 'name': new FormControl(this.name) }) } } "},"angular/study_notes/from/02_directives.html":{"url":"angular/study_notes/from/02_directives.html","title":"directives_源码解析","keywords":"","body":"/** * @license * Copyright Google Inc. All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */ import { ChangeDetectionStrategy } from '../change_detection/constants'; import { Provider } from '../di'; import { Type } from '../type'; import { TypeDecorator } from '../util/decorators'; import { ViewEncapsulation } from './view'; /** * 指令装饰器/构造函数的类型。 * * @stable */ export interface DirectiveDecorator { /** * @它能做什么 将类标记为Angular指令，并收集指令配置 * 元数据. * * @如何使用 * * `.`` * import {Directive} from '@angular/core'; * * @Directive({ * selector: 'my-directive', * }) * export class MyDirective { * } * `.`` * * @描述 * * 指令装饰器允许您将类标记为Angular指令，并提供其他元数据， * 以确定如何在运行时处理，实例化和使用伪指令。 * * 指令允许您将行为附加到DOM中的元素 * * 一个指令必须属于一个NgModule， * 以便它被另一个指令，组件或应用程序使用。 * 要指定一个指令是NgModule的成员， * 您应该将其列在该NgModule的“声明”字段中。 * * 除了通过指令装饰器指定的元数据配置之外, * 指令可以通过实现各种生命周期钩子来控制其运行时行为. * * **元数据属性:** * * * **exportAs** - 组件实例在模板中导出的名称 * * **host** - 类属性映射到事件，属性和属性的主机元素绑定 * * **inputs** - 将类属性名称列表作为组件输入的数据绑定 * * **outputs** - 列出其他可以订阅的输出事件的类属性名称 * * **providers** - 该组件及其子组件可用的提供程序列表 * * **queries** - 配置可以注入组件的查询 * * **selector** - css选择器，用于标识模板中的此组件 * * @稳定 * @注解 */ (obj: Directive): TypeDecorator; /** * 请参阅{@link指令}装饰器。 */ new (obj: Directive): Directive; } export interface Directive { /** * 触发实例化指令的CSS选择器。 * * Angular仅允许指令触发不跨越元素边界的CSS选择器。 * * `selector` 可以被声明为以下之一: * * - `element-name`: 按元素名称选择. * - `.class`: 按类名选择. * - `[attribute]`: 按属性名称选择. * - `[attribute=value]`: 按属性名称和值选择. * - `:not(sub_selector)`: 只有当元素不匹配`sub_selector`时才选择. * - `selector1, selector2`: 选择“selector1”或“selector2”是否匹配. * * * ### 例 * * 假设我们有一个`input [type = text]选择器的指令。 * * 和以下HTML: * * `.``html * * * * * `.`` * * 该指令只能在`“元素上实例化. * */ selector?: string; /** * 枚举一个指令的数据绑定输入属性集 * * Angular在更改检测期间自动更新输入属性. * * `inputs`属性将一组`directiveProperty`定义为`bindingProperty` 组态: * * - `directiveProperty`指定写入值的组件属性. * - `bindingProperty`指定读取值的DOM属性. * * 当没有提供`bindingProperty`时，它被假定为等于`directiveProperty`. * * ### 示例（[live demo]（http://plnkr.co/edit/ivhfXY?p=preview）） * * 以下示例创建具有两个数据绑定属性的组件. * * `.``typescript * @Component({ * selector: 'bank-account', * inputs: ['bankName', 'id: account-id'], * template: ` * Bank Name: {{bankName}} * Account Id: {{id}} * ` * }) * class BankAccount { * bankName: string; * id: string; * * // 此属性未绑定，不会被Angular自动更新 * normalizedBankName: string; * } * * @Component({ * selector: 'app', * template: ` * * ` * }) * class App {} * `.`` * */ inputs?: string[]; /** * 枚举一组事件绑定的输出属性。 * * 当输出属性发出一个事件时，附加到该事件的事件处理程序调用该模板。 * * `outputs`属性将一组`directiveProperty`定义为`bindingProperty`配置: * * - `directiveProperty`指定发出事件的组件属性. * - `bindingProperty`指定事件处理程序所附加的DOM属性. * * ### 示例（[live demo]（http://plnkr.co/edit/d5CNq7?p=preview）） * * `.``typescript * @Directive({ * selector: 'interval-dir', * outputs: ['everySecond', 'five5Secs: everyFiveSeconds'] * }) * class IntervalDir { * everySecond = new EventEmitter(); * five5Secs = new EventEmitter(); * * constructor() { * setInterval(() => this.everySecond.emit(\"event\"), 1000); * setInterval(() => this.five5Secs.emit(\"event\"), 5000); * } * } * * @Component({ * selector: 'app', * template: ` * * * ` * }) * class App { * everySecond() { console.log('second'); } * everyFiveSeconds() { console.log('five seconds'); } * } * `.`` * */ outputs?: string[]; /** * 指定与主机元素相关的事件，操作，属性和属性. * * ## 主机监听器 * * 通过一组`（event）`指向`method`来指定一个指令侦听哪个DOM事件 * 键值对: * * - `event`: 指令监听的DOM事件. * - `statement`: 发生事件时执行的语句. * 如果该语句的评估返回`false`，那么`preventDefault`应用于DOM事件 * * 要侦听全局事件，必须将事件名称添加到目标. * 目标可以是“window”，“document”或“body”. * * 编写指令事件绑定时，还可以参考$ event局部变量. * * ### 示例（[live demo]（http://plnkr.co/edit/DlA5KU?p=preview）） * * 以下示例声明将点击监听器附加到按钮并计数点击的指令. * * `.``typescript * @Directive({ * selector: 'button[counting]', * host: { * '(click)': 'onClick($event.target)' * } * }) * class CountClicks { * numberOfClicks = 0; * * onClick(btn) { * console.log(\"button\", btn, \"number of clicks:\", this.numberOfClicks++); * } * } * * @Component({ * selector: 'app', * template: `Increment` * }) * class App {} * `.`` * * ## 主机属性绑定 * * 指定指令更新的DOM属性。 * * 在更改检测期间，Angular会自动检查主机属性绑定. * 如果绑定更改，它将更新指令的主机元素. * * ### 示例（[live demo]（http://plnkr.co/edit/gNg0ED?p=preview）） * * 以下示例创建了一个在DOM元素上设置“valid”和“invalid”类的指令， * 该元素具有ngModel伪指令. * * `.``typescript * @Directive({ * selector: '[ngModel]', * host: { * '[class.valid]': 'valid', * '[class.invalid]': 'invalid' * } * }) * class NgModelStatus { * constructor(public control:NgModel) {} * get valid { return this.control.valid; } * get invalid { return this.control.invalid; } * } * * @Component({ * selector: 'app', * template: `` * }) * class App { * prop; * } * `.`` * * ## 属性 * * 指定应传播到主机元素的静态属性. * * ### 例 * * 在这个例子中， * 使用主机元素（这里：``）上的`my-button`指令 * （例如：` `）将确保该元素将获得“按钮 “角色。. * * `.``typescript * @Directive({ * selector: '[my-button]', * host: { * 'role': 'button' * } * }) * class MyButton { * } * `.`` */ host?: { [key: string]: string; }; /** * 定义指令和其轻型DOM子项可见的可注射对象集合. * * ## 简例 * * 这是一个可以注入的类的例子: * * `.`` * class Greeter { * greet(name:string) { * return 'Hello ' + name + '!'; * } * } * * @Directive({ * selector: 'greet', * providers: [ * Greeter * ] * }) * class HelloWorld { * greeter:Greeter; * * constructor(greeter:Greeter) { * this.greeter = greeter; * } * } * `.`` */ providers?: Provider[]; /** * 定义可以在模板中使用的名称，以将此指令分配给变量. * * ## 简例 * * `.`` * @Directive({ * selector: 'child-dir', * exportAs: 'child' * }) * class ChildDir { * } * * @Component({ * selector: 'main', * template: `` * }) * class MainComponent { * } * * `.`` */ exportAs?: string; /** * 配置将注入到指令中的查询. * * 内容查询在调用`ngAfterContentInit`回调之前设置. * 查询查询是在调用`ngAfterViewInit`回调之前设置的. * * ### 例 * * `.`` * @Component({ * selector: 'someDir', * queries: { * contentChildren: new ContentChildren(ChildDirective), * viewChildren: new ViewChildren(ChildDirective) * }, * template: '' * }) * class SomeDir { * contentChildren: QueryList, * viewChildren: QueryList * * ngAfterContentInit() { * // 内容节点设置 * } * * ngAfterViewInit() { * // 设图节点设在 * } * } * `.`` */ queries?: { [key: string]: any; }; } /** * 指令装饰器和元数据. * * @稳定 * @注解 */ export declare const Directive: DirectiveDecorator; /** * Component装饰器/构造函数的类型. * * @stable */ export interface ComponentDecorator { /** * @whatItDoes将类标记为角度组件并收集组件配置元数据. * * @如何使用 * * {@example core/ts/metadata/metadata.ts region='component'} * * @描述 * 组件装饰器允许您将类标记为角度组件， * 并提供其他元数据，以确定如何在运行时处理， * 实例化和使用组件. * * 组件是Angular应用程序中UI最基本的构建块. * Angular应用是一个角度的组件树. * Angular组件是指令的一个子集。 * 与指令不同，组件始终具有模板， * 并且只能在模板中的元素中实例化一个组件. * * 组件必须属于NgModule， * 以便它可以被另一个组件或应用程序使用。 * 要指定组件是NgModule的成员， * 应将其列在该NgModule的“声明”字段中。 * * 除了通过Component装饰器指定的元数据配置之外, * 组件可以通过实现各种生命周期钩子来控制其运行时行为. * * **元数据属性:** * * * **animations** - 该组件的动画列表 * * **changeDetection** - 改变该组件使用的检测策略 * * **encapsulation** - 该组件使用的样式封装策略 * * **entryComponents** - 动态插入到此组件的视图中的组件列表 * * **exportAs** - 组件实例在模板中导出的名称 * * **host** - 类属性映射到事件，属性和属性的主机元素绑定 * * **inputs** - 将类属性名称列表作为组件输入的数据绑定 * * **interpolation** - 此组件模板中使用的自定义插值标记 * * **moduleId** - 定义此组件的文件的ES / CommonJS模块ID * * **outputs** - 列出其他可以订阅的输出事件的类属性名称 * * **providers** - 该组件及其子组件可用的提供程序列表 * * **queries** - 配置可以注入组件的查询 * * **selector** - css选择器，用于标识模板中的此组件 * * **styleUrls** - 要应用于此组件视图的样式表的URL列表 * * **styles** - 内联定义的样式应用于此组件的视图 * * **template** - 视图的内联定义模板 * * **templateUrl** - url到包含视图模板的外部文件 * * **viewProviders** - 此组件及其查看子项可用的提供程序列表 * * ### 例 * * {@example core/ts/metadata/metadata.ts region='component'} * * @stable * @Annotation */ (obj: Component): TypeDecorator; /** * 请参阅{@link Component}装饰器。 */ new (obj: Component): Component; } /** * 组件元数据的类型. * * @stable */ export interface Component extends Directive { /** * 定义使用的变更检测策略. * * 当一个组件被实例化时，Angular创建一个变化检测器， * 它负责传播组件的绑定. * * `changeDetection`属性定义， * 是否会每次检查更改检测，或仅当组件告诉它进行检查时. */ changeDetection?: ChangeDetectionStrategy; /** * 定义可视对象的集合，使其DOM DOM子项的视图可见. * * ## Simple Example * * 这是一个可以注入的类的例子: * * `.`` * class Greeter { * greet(name:string) { * return 'Hello ' + name + '!'; * } * } * * @Directive({ * selector: 'needs-greeter' * }) * class NeedsGreeter { * greeter:Greeter; * * constructor(greeter:Greeter) { * this.greeter = greeter; * } * } * * @Component({ * selector: 'greet', * viewProviders: [ * Greeter * ], * template: `` * }) * class HelloWorld { * } * * `.`` */ viewProviders?: Provider[]; /** * 包含组件的模块的模块ID. * 需要能够解析模板和样式的相对URL. * 在CommonJS中，这可以始终设置为`module.id`，同样的SystemJS在每个模块中都会显示`__moduleName`变量. * * * ## 简例 * * `.`` * @Directive({ * selector: 'someDir', * moduleId: module.id * }) * class SomeDir { * } * * `.`` */ moduleId?: string; /** * 指定Angular组件的模板URL. * *每个View只能定义“templateUrl”或“template”之一. */ templateUrl?: string; /** * 指定Angular组件的内联模板. * * 每个组件只能定义“templateUrl”或“template”之一. */ template?: string; /** * 指定Angular组件的样式表URL. */ styleUrls?: string[]; /** * 指定Angular组件的内联样式表. */ styles?: string[]; /** * 通过类似动画的DSL在组件上定义动画。 * 描述动画的这种DSL方法允许灵活性， * 这既有益于开发人员和框架. * * 通过侦听在模板中的元素上发生的状态更改来进行动画处理。 * 当发生状态变化时，角度可以利用它们之间的弧线并使其动画化。 * 这与CSS过渡的工作方式类似，但是通过使用编程式DSL，动画不限于DOM特定的环境. * (Angular还可以在幕后进行优化，使动画更加出色.) * * 为了使动画可以使用，动画状态更改位于{@link触发器动画触发器}中， * 它们位于“动画”注释元数据的内部。 * 在触发器中，可以放置{@link状态}和{@link转换转换}条目. * * `.``typescript * @Component({ * selector: 'animation-cmp', * templateUrl: 'animation-cmp.html', * animations: [ * // 这是我们的动画触发器，它将包含我们的状态变化动画. * trigger('myTriggerName', [ * // 动画完成后，为元素定义的“on”和“off”状态的样式将保留在元素上. * state('on', style({ opacity: 1 }), * state('off', style({ opacity: 0 }), * * // 这是我们的动画，当这个状态变化跳跃是真的时，它开始了 * transition('on => off', [ * animate(\"1s\") * ]) * ]) * ] * }) * `.`` * * 如上面的代码所示， * 一组相关的动画状态都包含在动画“触发器”（上面的代码示例称为触发器iggerName）中）。 * 当触发器被创建时，它可以被绑定到组件模板中的一个元素上， * 前缀是一个前缀为“@”符号的属性，后跟触发器名称和用于确定该触发器的状态值的表达式. * * `.``html * * ... * `.`` * * 对于要执行的状态更改，“expression”值必须将值从现有值更改为我们将动画设置为动画 * （在上面的示例中，我们正在监听“on”和“off”之间的状态更改`）。 * 附加到触发器的“expression”值必须是可以使用模板/组件上下文来评估的值. * * ### DSL动画功能 * * 请访问下面列出的每个动画DSL功能，以更好地了解如何以及为什么用于在Angular中制作动画: * * - {@link trigger trigger()} * - {@link state state()} * - {@link transition transition()} * - {@link group group()} * - {@link sequence sequence()} * - {@link style style()} * - {@link animate animate()} * - {@link keyframes keyframes()} */ animations?: any[]; /** * 指定模板和样式应如何封装: * - {@link ViewEncapsulation#Native `ViewEncapsulation.Native`} to use shadow roots - 仅在平台上可用的情况下才起作用, * - {@link ViewEncapsulation#Emulated `ViewEncapsulation.Emulated`} 使用模仿本机行为的shimmed CSS, * - {@link ViewEncapsulation#None `ViewEncapsulation.None`} 使用全局CSS而没有任何封装. * * 当没有为组件定义“封装”时，将使用{@link CompilerOptions}中的默认值。 默认为“ViewEncapsulation.Emulated”}。 提供一个新的`CompilerOptions`来覆盖这个值. * * 如果封装设置为“ViewEncapsulation.Emulated”，并且组件没有“样式”和“styleUrls”，封装将自动切换到“ViewEncapsulation.None”. */ encapsulation?: ViewEncapsulation; /** * 覆盖默认的封装开始和结束分隔符（分别为{{`和`}}`） */ interpolation?: [string, string]; /** * 定义此组件时，还要定义应编译的组件。 对于此处列出的每个组件，Angular将创建一个{@link ComponentFactory}并将其存储在{@link ComponentFactoryResolver}. */ entryComponents?: Array | any[]>; } /** * 组件装饰器和元数据. * * @stable * @Annotation */ export declare const Component: ComponentDecorator; /** * 管道装饰器/构造函数的类型. * * @stable */ export interface PipeDecorator { /** * 声明可重复使用的管道功能. * * 只有当输入或任何参数发生变化时，才会重新评估“纯”管道. * * 当未指定时，管道默认为纯. */ (obj: Pipe): TypeDecorator; /** * 请参阅{@link Pipe}装饰器. */ new (obj: Pipe): Pipe; } /** * 管道元数据的类型. * * @stable */ export interface Pipe { name: string; pure?: boolean; } /** * 管道装饰器和元数据. * * @stable * @Annotation */ export declare const Pipe: PipeDecorator; /** * 输入装饰器/构造函数的类型. * * @stable */ export interface InputDecorator { /** * 声明数据绑定输入属性. * * Angular. * * `Input`接受一个可选参数，指定在模板中实例化组件时使用的名称。 未提供时，将使用装饰属性的名称. * * ### Example * * 以下示例创建一个具有两个输入属性的组件. * * `.``typescript * @Component({ * selector: 'bank-account', * template: ` * Bank Name: {{bankName}} * Account Id: {{id}} * ` * }) * class BankAccount { * @Input() bankName: string; * @Input('account-id') id: string; * * // 此属性未绑定，不会被Angular自动更新 * normalizedBankName: string; * } * * @Component({ * selector: 'app', * template: ` * * ` * }) * * class App {} * `.`` * @stable */ (bindingPropertyName?: string): any; new (bindingPropertyName?: string): any; } /** * 输入元数据的类型. * * @stable */ export interface Input { /** * 在模板中实例化组件时使用的名称. */ bindingPropertyName?: string; } /** * 输入装饰器和元数据. * * @stable * @Annotation */ export declare const Input: InputDecorator; /** * 输出装饰器/构造函数的类型. * * @stable */ export interface OutputDecorator { /** * 声明一个事件绑定的输出属性. * * 当输出属性发出一个事件时，附加到该事件的事件处理程序调用该模板. * * `Output`采用一个可选参数，指定在模板中实例化组件时使用的名称。 * 未提供时，将使用装饰属性的名称. * * ### 例 * * `.``typescript * @Directive({ * selector: 'interval-dir', * }) * class IntervalDir { * @Output() everySecond = new EventEmitter(); * @Output('everyFiveSeconds') five5Secs = new EventEmitter(); * * constructor() { * setInterval(() => this.everySecond.emit(\"event\"), 1000); * setInterval(() => this.five5Secs.emit(\"event\"), 5000); * } * } * * @Component({ * selector: 'app', * template: ` * * * ` * }) * class App { * everySecond() { console.log('second'); } * everyFiveSeconds() { console.log('five seconds'); } * } * `.`` * @stable */ (bindingPropertyName?: string): any; new (bindingPropertyName?: string): any; } /** * 输出元数据的类型. * * @stable */ export interface Output { bindingPropertyName?: string; } /** * 输出装饰器和元数据. * * @stable * @Annotation */ export declare const Output: OutputDecorator; /** * HostBinding装饰器/构造函数的类型. * * @stable */ export interface HostBindingDecorator { /** * 声明主机属性绑定. * * 在更改检测期间，Angular会自动检查主机属性绑定. * 如果绑定更改，它将更新指令的主机元素. * * `HostBinding`接受一个可选参数， * 指定要更新的主机元素的属性名称。 * 未提供时，使用类属性名称. * * ### 例 * * 以下示例创建了一个在DOM元素上设置“valid”和“invalid”类的指令，该元素具有ngModel伪指令. * * `.``typescript * @Directive({selector: '[ngModel]'}) * class NgModelStatus { * constructor(public control:NgModel) {} * @HostBinding('class.valid') get valid() { return this.control.valid; } * @HostBinding('class.invalid') get invalid() { return this.control.invalid; } * } * * @Component({ * selector: 'app', * template: ``, * }) * class App { * prop; * } * `.`` * @stable */ (hostPropertyName?: string): any; new (hostPropertyName?: string): any; } /** * HostBinding元数据的类型. * * @stable */ export interface HostBinding { hostPropertyName?: string; } /** * HostBinding装饰器和元数据. * * @stable * @Annotation */ export declare const HostBinding: HostBindingDecorator; /** * HostListener装饰器/构造函数的类型. * * @stable */ export interface HostListenerDecorator { /** * 声明主机侦听器. * * 当主机元素发出指定的事件时，Angular将调用装饰的方法. * * 如果装饰方法返回`false`，那么`preventDefault`应用于DOM事件. * * ### Example * * 以下示例声明将点击监听器附加到按钮并计数点击的指令. * * `.``typescript * @Directive({selector: 'button[counting]'}) * class CountClicks { * numberOfClicks = 0; * * @HostListener('click', ['$event.target']) * onClick(btn) { * console.log('button', btn, 'number of clicks:', this.numberOfClicks++); * } * } * * @Component({ * selector: 'app', * template: 'Increment', * }) * class App {} * `.`` * @stable * @Annotation */ (eventName: string, args?: string[]): any; new (eventName: string, args?: string[]): any; } /** * HostListener元数据的类型. * * @stable */ export interface HostListener { eventName?: string; args?: string[]; } /** * HostListener装饰器和元数据. * * @stable * @Annotation */ export declare const HostListener: HostListenerDecorator; "},"angular/study_notes/from/03_ng_model.html":{"url":"angular/study_notes/from/03_ng_model.html","title":"ngModel","keywords":"","body":"双向绑定数据写法说明 双向绑定数据的写法是[(ngModel)]=\"modelName\".modelName命名必须为有意义,如:productName 使用: 环境: // 必须在根模块导入 FormsModule 才可以使用 ngModel import {FormsModule} from '@angular/forms'; @NgModule({ // ... imports: [ // ... FormsModule // ... ] //... }) 设置app.module.ts // 下面是引入开发使用到的库(模板仓库) import {BrowserModule} from '@angular/platform-browser'; import {NgModule} from '@angular/core'; import {FormsModule,ReactiveFormsModule} from '@angular/forms'; // 组件引入方式如下: // import { NgModelComponent } from './ng-model/ng-model.component'; @NgModule({ declarations: [ // ... 这里是引入组件 // NgModelComponent ], // 导入库 imports: [ BrowserModule, FormsModule, ReactiveFormsModule ], providers: [], bootstrap: [AppComponent] }) 创建组件 $ ng generate component ngModel # installing component # create src/app/ok/ng-model.component.css # create src/app/ok/ng-model.component.html # create src/app/ok/ng-model.component.spec.ts # create src/app/ok/ng-model.component.ts # update src/app/app.module.ts 设置ng-model组件样式 Product Name The product name is: {{productName}} 提交 重置 设置ng-model组件逻辑部分 import {Component, OnInit} from '@angular/core'; import { FormBuilder, FormGroup, Validators, } from \"@angular/forms\" @Component({ selector: 'app-ng-model', templateUrl: './ng-model.component.html', styleUrls: ['./ng-model.component.css'] }) export class NgModelComponent implements OnInit { myForm: FormGroup; productName: string; // 注入: FormBuilder /*在这期间, Angular将会注入一个从 FormBuilder 类创建的对象实例,并把它赋值给 fb 变量(来 自构造函数)*/ constructor(fb: FormBuilder) { this.myForm = fb.group({ 'productName': ['', Validators.required] }) } onSubmit(value: string): void { console.log('你的提交值', value); } ngOnInit() { } } "},"angular/study_notes/from/04_Form-Validation_&_Custom-Validator.html":{"url":"angular/study_notes/from/04_Form-Validation_&_Custom-Validator.html","title":"表单验证&自定义验证器","keywords":"","body":"HTML 演示形式：具有自定义验证 SKU SKU无效 SKU是必需的 SKU必须开头以123开始 表单无效 提交 TS import {Component, OnInit} from '@angular/core'; // import { FormBuilder, FormGroup, Validators, AbstractControl, FormControl } from \"@angular/forms\" // 自定义验证器 /*用正则匹配 传入的值是否以 123 开始.根据传入参数返回 boolean*/ function skuValidator(control: FormControl): { [s: string]: boolean } { if (!control.value.match(/^123/)) { return {invalidSku: true}; } } @Component({ selector: 'form-builder', templateUrl: './form-builder.component.html', styleUrls: ['./form-builder.component.css'] }) export class FormBuilderComponent implements OnInit { name: string; myFoem: FormGroup; sku: AbstractControl; // 注入: FormBuilder /*在这期间, Angular将会注入一个从 FormBuilder 类创建的对象实例,并把它赋值给 fb 变量(来 自构造函数)*/ constructor(fb: FormBuilder) { this.myFoem = fb.group({ 'sku': ['', Validators.compose([ Validators.required,skuValidator]) ] }) this.sku = this.myFoem.controls['sku'] } onSubmit(value: string): void { console.log('你的提交值', value); } ngOnInit() { } } "},"angular/study_notes/from/05_Listen_to_form_data_changes.html":{"url":"angular/study_notes/from/05_Listen_to_form_data_changes.html","title":"监听表单数据变化","keywords":"","body":"HTML 演示形式：具有自定义验证 SKU SKU无效 SKU是必需的 SKU必须开头以123开始 表单无效 提交 // 附上依赖，以示留记 import {Component, OnInit} from '@angular/core'; import { FormBuilder, FormGroup, Validators, AbstractControl, FormControl } from \"@angular/forms\" // 自定义验证器 /*当输入值(控件的值 control.value )不是以 123 作为开始时,验证器会返回错误代码 invalidSku 。*/ function skuValidator(control: FormControl): { [s: string]: boolean } { if (!control.value.match(/^123/)) { return {invalidSku: true}; } } @Component({ selector: 'app-event-emitter', templateUrl: './event-emitter.component.html', styleUrls: ['./event-emitter.component.css'] }) export class EventEmitterComponent implements OnInit { name: string; myForm: FormGroup; sku: AbstractControl; // 注入: FormBuilder /*在这期间, Angular将会注入一个从 FormBuilder 类创建的对象实例,并把它赋值给 fb 变量(来 自构造函数)*/ constructor(fb: FormBuilder) { this.myForm = fb.group({ 'sku': ['', Validators.compose([ Validators.required,skuValidator]) ] }) this.sku = this.myForm.controls['sku'] // 监听变化 /* (1) 通过调用 control.valueChanges 访问到这个 EventEmitter ; (2) 然后使用 .subscribe 方法添加一个监听器。 */ this.sku.valueChanges.subscribe( (value: string) => { console.log('sku changed to:', value); } ); this.myForm.valueChanges.subscribe( (form: any) => { console.log('form changed to:', form); } ); } onSubmit(value: string): void { console.log('你的提交值', value); } ngOnInit() { } } "},"angular/study_notes/from/06_Problem_collection.html":{"url":"angular/study_notes/from/06_Problem_collection.html","title":"问题收集","keywords":"","body":"1 Failed to compile. /home/seam/Code/Angular/myApp/src/app/http-client/http-client.component.ts (4,1): Decorators are not valid here. 出现原因: 通过html import {Component, OnInit} from '@angular/core'; import {HttpClient} from '@angular/common/http'; @Component({ selector: 'app-http-client', templateUrl: './http-client.component.html', styleUrls: ['./http-client.component.css'] }) interface ProductResponse { message: string; } interface ItemsResponse { results: string[]; } export class HttpClientComponent implements OnInit { constructor(private http: HttpClient) { } ngOnInit(): void { this.http.get ('http://api.yiguanjia.me/index.php?r=o2o/product/list').subscribe(res => console.log(res.results) ); } } "},"angular/ng.html":{"url":"angular/ng.html","title":"ng","keywords":"","body":"ng的使用 安装 sudo npm install -g angular-cli 查看版本 ng --version 查看帮助 ng help 创建项目 ng new my-peoject1 启动 ng server # or 启动AOT项目 ng server --prod --aot 编译项目 ng build # or AOT编译 ng build --prod --aot 使用less # 初始化项目时 ng new my-app --style less # 已有项目,编辑 .angualr-cli.json 设置defaults.styleExt值less。 # 使用 ng 指令 ng set defaults.styleExt less "},"css/principle/":{"url":"css/principle/","title":"原理解析","keywords":"","body":"原理解析 加快您的网站的最佳实践 "},"css/principle/0.html":{"url":"css/principle/0.html","title":"1px 边框问题","keywords":"","body":"1px 边框问题 7 种方法解决移动端 Retina 屏幕 1px 边框问题 在 retina 屏中实现 1px border 效果 下文出自7 种方法解决移动端 Retina 屏幕 1px 边框问题 造成边框变粗的原因 其实这个原因很简单，因为 css 中的 1px 并不等于移动设备的 1px，这些由于不同的手机有不同的像素密度。在 window 对象中有一个 devicePixelRatio 属性，他可以反应 css 中的像素与设备的像素比。 devicePixelRatio 的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。 0.5px 边框 if (window.devicePixelRatio && devicePixelRatio >= 2) { var testElem = document.createElement(\"div\"); testElem.style.border = \".5px solid transparent\"; document.body.appendChild(testElem); if (testElem.offsetHeight == 1) { document.querySelector(\"html\").classList.add(\"hairlines\"); } document.body.removeChild(testElem); } // 脚本应该放在内，如果在里面运行，需要包装 $(document).ready(function() {}) div { border: 1px solid #bbb; } .hairlines div { border-width: 0.5px; } 使用 border-image 实现 /* 底部边框 */ .border-bottom-1px { border-width: 0 0 1px 0; -webkit-border-image: url(linenew.png) 0 0 2 0 stretch; border-image: url(linenew.png) 0 0 2 0 stretch; } /* 上下边框 */ .border-image-1px { border-width: 1px 0; -webkit-border-image: url(linenew.png) 2 0 stretch; border-image: url(linenew.png) 2 0 stretch; } /* 使用Media Query做兼容 */ .border-image-1px { border-bottom: 1px solid #666; } @media only screen and (-webkit-min-device-pixel-ratio: 2) { .border-image-1px { border-bottom: none; border-width: 0 0 1px 0; -webkit-border-image: url(../img/linenew.png) 0 0 2 0 stretch; border-image: url(../img/linenew.png) 0 0 2 0 stretch; } } 使用 background-image 实现 .background-image-1px { background: url(../img/line.png) repeat-x left bottom; -webkit-background-size: 100% 1px; background-size: 100% 1px; } 多背景渐变实现 .background-gradient-1px { background: linear-gradient(180deg, black, black 50%, transparent 50%) top left / 100% 1px no-repeat, linear-gradient( 90deg, black, black 50%, transparent 50% ) top right / 1px 100% no-repeat, linear-gradient(0, black, black 50%, transparent 50%) bottom right / 100% 1px no-repeat, linear-gradient( -90deg, black, black 50%, transparent 50% ) bottom left / 1px 100% no-repeat; } /* 或者 */ .background-gradient-1px { background: -webkit-gradient( linear, left top, left bottom, color-stop(0.5, transparent), color-stop(0.5, #c8c7cc), to(#c8c7cc) ) left bottom repeat-x; background-size: 100% 1px; } 使用 box-shadow 模拟边框 .box-shadow-1px { box-shadow: inset 0px -1px 1px -1px #c8c7cc; } viewport + rem 实现 同时通过设置对应 viewport 的 rem 基准值，这种方式就可以像以前一样轻松愉快的写 1px 了。在 devicePixelRatio = 2 时，输出 viewport： 在devicePixelRatio = 3 时，输出viewport： ```html 这种兼容方案相对比较完美，适合新的项目，老的项目修改成本过大。对于这种方案，可以看看《使用 Flexible 实现手淘 H5 页面的终端适配》 伪类 + transform 实现 单条 border 样式设置： .scale-1px { position: relative; border: none; } .scale-1px:after { content: \"\"; position: absolute; bottom: 0; background: #000; width: 100%; height: 1px; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); -webkit-transform-origin: 0 0; transform-origin: 0 0; } 四条 boder 样式设置: .scale-1px { position: relative; margin-bottom: 20px; border: none; } .scale-1px:after { content: \"\"; position: absolute; top: 0; left: 0; border: 1px solid #000; -webkit-box-sizing: border-box; box-sizing: border-box; width: 200%; height: 200%; -webkit-transform: scale(0.5); transform: scale(0.5); -webkit-transform-origin: left top; transform-origin: left top; } if (window.devicePixelRatio && devicePixelRatio >= 2) { document.querySelector(\"ul\").className = \"scale-1px\"; } "},"css/principle/01.html":{"url":"css/principle/01.html","title":"border-style","keywords":"","body":"border-style 属性定义及使用说明 border-style属性设置一个元素的四个边框的样式。此属性可以有一到四个值。 border-style:dotted solid double dashed; 值 描述 dotted 上边框是点状 solid 右边框是实线 double 下边框是双线 dashed 左边框是虚线 border-style:dotted solid double; 值 描述 dotted 上边框是点状 solid 右边框和左边框是实线 double 下边框是双线 border-style:dotted solid; 值 描述 dotted 上边框和下边框是点状 solid 右边框和左边框是实线 border-style:dotted; 所有4个边框都是点状 值 描述 none 定义无边框。 hidden 与 \"none\" 相同。不过应用于表时除外，对于表，hidden 用于解决边框冲突。 dotted 定义点状边框。在大多数浏览器中呈现为实线。 dashed 定义虚线。在大多数浏览器中呈现为实线。 solid 定义实线。 double 定义双线。双线的宽度等于 border-width 的值。 groove 定义 3D 凹槽边框。其效果取决于 border-color 的值。 ridge 定义 3D 垄状边框。其效果取决于 border-color 的值。 inset 定义 3D inset 边框。其效果取决于 border-color 的值。 outset 定义 3D outset 边框。其效果取决于 border-color 的值。 inherit 规定应该从父元素继承边框样式。 "},"css/principle/02.html":{"url":"css/principle/02.html","title":"CSS盒子","keywords":"","body":"CSS盒子 标准CSS盒子与低版本CSS盒子有什么区别 区别在于 标准的CSS盒子模型的宽指的是内容区域（ content）的宽 低版本的CSS盒子模型的宽指的是 内容区域 + 填充区 + 边界宽； "},"css/cases/":{"url":"css/cases/","title":"案例收集","keywords":"","body":"案例 埋坑 字体去抗锯齿 示例: -webkit-font-smoothing:antialiased; 有三种可选值： none|subpixel-antialiased|antialiased 第一个坑：设置input输入框背景色 可以改变任何情况下的背景色设定 box-shadow: 0 0 0px 1000px rgb(255, 255, 255) inset; -o-box-shadow: 0 0 0px 1000px rgb(255, 255, 255) inset; -moz-box-shadow: 0 0 0px 1000px rgb(255, 255, 255) inset; -webkit-box-shadow: 0 0 0px 1000px rgb(255, 255, 255) inset; 第二个坑：buttom边框虚线 outline（轮廓）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。 utline: 0; 第三个坑：文本不换行 规定段落中的文本不进行换行： white-space: nowrap "},"css/cases/0_.html":{"url":"css/cases/0_.html","title":"去除表格单元格边距","keywords":"","body":"去除表格单元格边距 Name Age City {{ p.name }} {{ p.age }} {{ p.city }} "},"css/cases/01_.html":{"url":"css/cases/01_.html","title":"媒体查询","keywords":"","body":" 媒体查询 /*常用案例展示,其他案例暂时不做过多记录 screen:用于 电脑 平板 手机端 and 后跟最大宽度500px 表示只有满足 screen 和 最大宽度是500px 的情况下,才会执行的css语句 */ @media only screen and (max-width: 500px) { .gridmenu { width:100%; } .gridmain { width:100%; } .gridright { width:100%; } } "},"css/cases/02_.html":{"url":"css/cases/02_.html","title":"flex布局","keywords":"","body":"原文 1.box-flex属性 box-flex主要让子容器针对父容器的宽度按一定规则进行划分 01 02 03 acticle{ display: box; display: -moz-box; display: -webkit-box; width: 100%; height: 50px; } acticle section{ line-height: 50px; text-align: center; color:#fff; text-shadow: 1px 1px 1px rgb(0,0,0) } acticle section:nth-child(1){ background:orange; -moz-box-flex:2; -webkit-box-flex:2; box-flex:2; } acticle section:nth-child(2){ background:purple; -moz-box-flex:2; -webkit-box-flex:2; box-flex:2; } acticle section:nth-child(3){ -moz-box-flex:2; -webkit-box-flex:2; box-flex:2; background:green; }     必须给父容器wrap定义css属性display:box其子容器才可以进行划分 (如果定了display:box则该容器则定义为了内联元素，使用margin:0px auto让其居中是无效的，要想使其居中只能通过它的父容器的text-align:center);     分别给sectionOne、sectionTwo、sectionThree的box-flex设置了3、2、1，     也就是说这三个子容器将父容器wrap的宽度600px分为6份，sectionOne占居父结构宽度的3/6即300px，sectionOne占居父结构宽度的2/6即200px，sectionThree占居父结构宽度的1/6即100px。     以上是按比例数进行划分分配的，如果其中一个子容器或多个子容器设置了固定宽度又会怎样划分那？ 如果其中一个子容器或多个子容器设置了固定宽度，其它子容器没有设置，其计算方式是这样的：子容器如果设置了固定宽度值，该子容器则直接应用设置的宽度值，其它没有设置的则再父容器的宽度基础上减去子容器设置的固定宽度，在剩下的宽度基础上按一定比例进行划分分配。请看下面代码: 01 02 03 acticle{ display: box; display: -moz-box; display: -webkit-box; width: 100%; height: 50px; } acticle section{ line-height: 50px; text-align: center; color:#fff; text-shadow: 1px 1px 1px rgb(0,0,0) } acticle section:nth-child(1){ background:orange; -moz-box-flex:2; -webkit-box-flex:2; box-flex:2; } acticle section:nth-child(2){ background:purple; -moz-box-flex:2; -webkit-box-flex:2; box-flex:2; } acticle section:nth-child(3){ width:200px; background:green; } sectionThree设置了固定宽度为200px，父容器的宽度600px减去改子容器的200px还剩下400px，这400px宽度值则按box-flex设置的值进行划分，sectionOne占居3/4即300px,sectionTwo占居1/4即100px。 在以上代码的基础上给sectionTwo子容器添加margin:0px 50px使子容器之间产生一定的间隔其宽度又如何进行分配划分的那？接着看 01 02 03 acticle{ display: box; display: -moz-box; display: -webkit-box; width: 100%; height: 50px; } acticle section{ line-height: 50px; text-align: center; color:#fff; text-shadow: 1px 1px 1px rgb(0,0,0) } acticle section:nth-child(1){ background:orange; -moz-box-flex:2; -webkit-box-flex:2; box-flex:2; } acticle section:nth-child(2){ background:purple; -moz-box-flex:2; -webkit-box-flex:2; box-flex:2; /*添加margin属性*/ margin:0 50px; } acticle section:nth-child(3){ width:200px; background:green; } 父容器的宽度600px减去设置了子容器的200px基础上再减去100px(2×50)剩下300px，这300px宽度值则按box-flex设置的值进行划分，sectionOne占居3/4即225px,sectionTwo占居1/4即75px。 2.box属性 上面”css3弹性盒子模型之box-flex”将box-flex如何对父容器的宽度进行划分分配讲解完毕，下面在看一下父容器里面的box属性包括哪些box属性，具体属性如下代码所示： box-orient | box-direction | box-align | box-pack | box-lines a.box-orient box-orient(orient译为排列更准确)用来确定父容器里子容器的排列方式，是水平还是垂直。可选属性如下所示： horizontal | vertical | inline-axis | block-axis | inherit horizontal、inline-axis说明： 给box设置horizontal或inline-axis属性其效果似乎表现一致，都可将子容器水平排列，具体两者有什么实质差别暂时还没有搞清楚。如果父容器选择horizontal或inline-axis属性对子容器进行水平排列，其是对父容器的宽度进行分配划分。此时如果父容器定义了高度值，其子容器的高度值设置则无效状态，所有子容器的高度等于父容器的高度值；如果父容器不设置高度值，其子容器的高度值才有效并且取最大高度值的子容器的高度。 01 02 03 acticle{ width:100%; height:200px; display:-moz-box; display:-webkit-box; display:box; -moz-box-orient:horizontal; -webkit-box-orient:horizontal; /*水平排列*/ box-orient:horizontal; } acticle section{ line-height: 200px; text-align: center; color:#fff; text-shadow: 1px 1px 1px rgb(0,0,0) } acticle section:nth-child(1){ background:orange; -moz-box-flex:1; -webkit-box-flex:1; box-flex:1; } acticle section:nth-child(2){ background:purple; -moz-box-flex:2; -webkit-box-flex:2; box-flex:2; } acticle section:nth-child(3){ width:100px; background:green; } vertical、block-axis说明： 给box设置vertical或block-axis属性(此属性是默认值)其效果似乎表现一致，都可将子容器垂直排列，具体两者有什么实质差别暂时还没有搞清楚。如果父容器选择vertical或block-axis属性对子容器进行垂直排列，其是对父容器的高度进行分配划分。 此时如果父容器定义了宽度值，其子容器的宽度值设置则无效状态；如果父容器不设置宽度值，其子容器的宽度值才有效并且取最大宽度值的子容器的宽度。 01 02 03 acticle{ width:100%; height:200px; display:-moz-box; display:-webkit-box; display:box; -moz-box-orient:vertical; -webkit-box-orient:vertical; /*垂直排列*/ box-orient:vertical; } acticle section{ line-height: 200px; text-align: center; color:#fff; text-shadow: 1px 1px 1px rgb(0,0,0) } acticle section:nth-child(1){ background:orange; -moz-box-flex:1; -webkit-box-flex:1; box-flex:1; } acticle section:nth-child(2){ background:purple; -moz-box-flex:2; -webkit-box-flex:2; box-flex:2; } acticle section:nth-child(3){ height:100px; background:green; } inherit说明： inherit属性则是让子容器继承父容器的相关属性。 b.box-direction box-direction用来确定父容器里的子容器排列顺序，具体属性如下代码所示： normal | reverse | inherit normal是默认值 按照HTML文档里结构的先后顺序依次展示。如下代码，如果box-direction设置为normal，则结构依次展示sectionOne、sectionTwo、sectionThree. 01 02 03 acticle{ width:100%; height:200px; display:-moz-box; display:-webkit-box; display:box; /*设置mormal默认值*/ -moz-box-direction:normal; -webkit-box-direction:normal; box-direction:normal; } acticle section{ line-height: 200px; text-align: center; color:#fff; text-shadow: 1px 1px 1px rgb(0,0,0) } acticle section:nth-child(1){ background:orange; -moz-box-flex:1; -webkit-box-flex:1; box-flex:1; } acticle section:nth-child(2){ background:purple; -moz-box-flex:2; -webkit-box-flex:2; box-flex:2; } acticle section:nth-child(3){ width:100px; background:green; } reverse表示反转: 如上面所示设置nomal其结构的排列顺序为sectionOne、sectionTwo、sectionThree；如果设置reverse反转，其结构的排列顺序为sectionThree、sectionTwo、sectionOne. 01 02 03 acticle{ width:100%; height:200px; display:-moz-box; display:-webkit-box; display:box; /*设置mormal默认值*/ -moz-box-direction:reverse; -webkit-box-direction:reverse; box-direction:reverse; } acticle section{ line-height: 200px; text-align: center; color:#fff; text-shadow: 1px 1px 1px rgb(0,0,0) } acticle section:nth-child(1){ background:orange; -moz-box-flex:1; -webkit-box-flex:1; box-flex:1; } acticle section:nth-child(2){ background:purple; -moz-box-flex:2; -webkit-box-flex:2; box-flex:2; } acticle section:nth-child(3){ width:100px; background:green; } c.box-align box-align表示父容器里面子容器的垂直对齐方式，可选参数如下所示： start | end | center | baseline | stretch 01 02 03 acticle{ width:100%; height:200px; display:-moz-box; display:-webkit-box; display:box; /*设置mormal默认值*/ -moz-box-direction:stretch; -webkit-box-direction:stretch; box-direction:stretch; } acticle section{ line-height: 100px; text-align: center; color:#fff; text-shadow: 1px 1px 1px rgb(0,0,0) } acticle section:nth-child(1){ background:orange; -moz-box-flex:1; -webkit-box-flex:1; box-flex:1; } acticle section:nth-child(2){ background:purple; -moz-box-flex:2; -webkit-box-flex:2; box-flex:2; } acticle section:nth-child(3){ width:100px; background:green; } start 在box-align表示居顶对齐 end 在box-align表示居底对齐 center 在box-align表示居中对齐 stretch 在box-align表示拉伸，拉伸到与父容器等高 d.box-pack box-pack表示父容器里面子容器的水平对齐方式，可选参数如下所示： start | end | center | justify 01 02 03 acticle{ width:100%; height:200px; background: aquamarine; display:-moz-box; display:-webkit-box; display:box; -moz-box-pack:end; -webkit-box-pack:end; -o-box-pack:end; box-pack:end; } acticle section{ line-height: 100px; width: 100px; text-align: center; color:#fff; text-shadow: 1px 1px 1px rgb(0,0,0) } acticle section:nth-child(1){ background:orange; } acticle section:nth-child(2){ background:purple; } acticle section:nth-child(3){ background:green; } start 在box-pack表示水平居左对齐 end 在box-pack表示水平居右对齐 center 在box-pack表示水平居中对齐 justify 在box-pack表示水平等分父容器宽度（唯一遗憾的是，firefox与opera暂时不支持，只有safari、chrome支持） 小结 box-flex 用法 // 父元素 display: box; display: -moz-box; display: -webkit-box; // 子元素 -moz-box-flex:2; -webkit-box-flex:2; box-flex:2; > box box-orient | box-direction | box-align | box-pack | box-lines box-orient 属性 horizontal | vertical | inline-axis | block-axis | inherit 用于父元素对子容器排列 horizontal、inline-axis：水平排列 vertical、block-axis：垂直排列 inherit：继承父元素相关属性 box-direction box-direction用来确定父容器里的子容器排列顺序 参数： normal | reverse | inherit normal:默认值 reverse表示反转 用法： // 父元素 -moz-box-direction:normal; -webkit-box-direction:normal; box-direction:normal; box-align: box-align表示父容器里面子容器的垂直对齐方式 用法： // 父元素 -moz-box-direction:stretch; -webkit-box-direction:stretch; box-direction:stretch; 属性 start 在box-align表示居顶对齐 end 在box-align表示居底对齐 center 在box-align表示居中对齐 stretch 在box-align表示拉伸，拉伸到与父容器等高 box-pack 说明：box-pack表示父容器里面子容器的水平对齐方式 用法： /* 父元素 */ -moz-box-pack:end; -webkit-box-pack:end; -o-box-pack:end; box-pack:end; 参数： start | end | center | justify start 在box-pack表示水平居左对齐 end 在box-pack表示水平居右对齐 center 在box-pack表示水平居中对齐 justify 在box-pack表示水平等分父容器宽度（唯一遗憾的是，firefox与opera暂时不支持，只有safari、chrome支持） "},"css/cases/03_.html":{"url":"css/cases/03_.html","title":"css动画","keywords":"","body":"css动画 animation CSS animation属性是如下属性的一个简写属性形式: animation-name, animation-duration, animation-timing-function, animation-delay, animation-iteration-count, animation-direction 和 animation-fill-mode. /* @keyframes duration | timing-function | delay | iteration-count | direction | fill-mode | play-state | name */ animation: 3s ease-in 1s 2 reverse both paused slidein; /* @keyframes duration | timing-function | delay | name */ animation: 3s linear 1s slidein; /* @keyframes duration | name */ animation: 3s slidein; animation-delay 定义: CSS属性定义动画于何时开始，即从动画应用在元素上到动画开始的这段时间的长度。 语法: animation-delay: 3s; animation-delay: 2s, 4ms; animation-direction 定义: CSS 属性指示动画是否反向播放，它通常在简写属性animation中设定 语法: animation-direction: normal animation-direction: reverse animation-direction: alternate animation-direction: alternate-reverse animation-direction: normal, reverse animation-direction: alternate, reverse, normal 属性 作用 normal 每个循环内动画向前循环，换言之，每个动画循环结束，动画重置到起点重新开始，这是默认属性。 alternate 动画交替反向运行，反向运行时，动画按步后退，同时，带时间功能的函数也反向，比如，ease-in 在反向时成为ease-out。计数取决于开始时是奇数迭代还是偶数迭代 reverse 反向运行动画，每周期结束动画由尾到头运行。 alternate-reverse 反向交替， 反向开始交替;动画第一次运行时是反向的，然后下一次是正向，后面依次循环。决定奇数次或偶数次的计数从1开始。 animation-duration 定义: 属性指定一个动画周期的时长。 语法: animation-duration: 6s animation-duration: 120ms animation-duration: 1s, 15s animation-duration: 10s, 30s, 230ms 属性 作用 time 一个动画周期的时长，单位为秒(s)或者毫秒(ms)，无单位值无效。 animation-fill-mode 定义: 这个 CSS 属性用来指定在动画执行之前和之后如何给动画的目标应用样式。 语法 /* = none | forwards | backwards | both */ animation-fill-mode: none animation-fill-mode: forwards animation-fill-mode: backwards animation-fill-mode: both /* 可以应用多个参数，这个时候使用逗号隔开 */ /* 各个参数应用于与次序相对应的动画名 */ animation-fill-mode: none, backwards animation-fill-mode: both, forwards, none none 动画执行前后不改变任何样式 forwards 目标保持动画最后一帧的样式，最后一帧是哪个取决于animation-direction和 animation-iteration-count: animation-direction animation-iteration-count last keyframe encountered normal even or odd 100% or to reverse even or odd 0% or from alternate even 0% or from alternate odd 100% or to alternate-reverse even 100% or to alternate-reverse odd 0% or from backwards 动画采用相应第一帧的样式，保持 animation-delay，第一帧取法如下： animation-direction first relevant keyframe normal or alternate 0% or from reverse or alternate-reverse 100% or to both 动画将会执行 forwards 和 backwards 执行的动作。 animation-iteration-count 定义: CSS 属性 定义动画在结束前运行的次数 可以是1次 无限循环. 默认属性 animation 默认播放动画循环一次. 语法: /* 使用规范 = infinite | */ animation-iteration-count: infinite; animation-iteration-count: 3; animation-iteration-count: 2.3; animation-iteration-count: 2, 0, infinite; animation-name 定义 属性指定应用的一系列动画，每个名称代表一个由@keyframes定义的动画序列。 /* Single animation */ animation-name: none; animation-name: test_05; animation-name: -specific; animation-name: sliding-vertically; /* Multiple animations */ animation-name: test1, animation4; animation-name: none, -moz-specific, sliding; /* Global values */ animation-name: initial animation-name: inherit animation-name: unset animation-play-state 定义: CSS 属性定义一个动画是否运行或者暂停。 可以通过查询它来确定动画是否正在运行。 另外，它的值可以被设置为暂停和恢复的动画的重放。 恢复一个已暂停的动画，将从它开始暂停的时候，而不是从动画序列的起点开始在动画。 语法 /* 正式语法 => = running | paused */ /* Single animation=>单一动画 */ animation-play-state: running; animation-play-state: paused; /* Multiple animations=>多个动画 */ animation-play-state: paused, running, running; /* Global values=>全球价值 */ animation-play-state: inherited; animation-play-state: initial; animation-play-state: unset; 属性 注释 running 当前动画正在运行。 paused 当前动画以被停止。 animation-timing-function 属性 定义CSS动画在每一动画周期中执行的节奏。 可能值为一或多个 。 对于关键帧动画来说，timing function作用于一个关键帧周期而非整个动画周期， 即从关键帧开始开始，到关键帧结束结束。 定义于一个关键帧区块的缓动函数(animation timing function)应用到改关键帧； 另外，若该关键帧没有定义缓动函数，则使用定义于整个动画的缓动函数。 示例 /* Keyword values */ animation-timing-function: ease; animation-timing-function: ease-in; animation-timing-function: ease-out; animation-timing-function: ease-in-out; animation-timing-function: linear; animation-timing-function: step-start; animation-timing-function: step-end; /* Function values */ animation-timing-function: cubic-bezier(0.1, 0.7, 1.0, 0.1); animation-timing-function: steps(4, end); animation-timing-function: frames(10); /* Multiple animations */ animation-timing-function: ease, step-start, cubic-bezier(0.1, 0.7, 1.0, 0.1); /* Global values */ animation-timing-function: inherit; animation-timing-function: initial; animation-timing-function: unset; 值 描述 linear 动画从头到尾的速度是相同的 ease 默认。动画以低速开始，然后加快，在结束前变慢。 ease-in 动画以低速开始。 ease-out 动画以低速结束。 ease-in-out 动画以低速开始和结束. cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。 FAQ 贝塞尔曲线(cubic-bezier) 疑惑点: animation-timing-function: cubic-bezier(0.1, 0.7, 1.0, 0.1); CSS3 timing-function: steps() 详解 animation-timing-function: steps(4, end); Cylon 眼睛 考虑到所有浏览器特定的前缀，这里是一个Cylon 眼睛动画合并线性渐变和动画，适用于所有主要的浏览器： Listening for dispatches .polling_message { color:white; float:left; margin-right:2%; } .view_port { background-color:black; height:25px; width:100%; overflow: hidden; } .cylon_eye { color:white; height: 100%; width: 20%; background-color: red; background-image: -webkit-linear-gradient(left, rgba( 0,0,0,0.9 ) 25%, rgba( 0,0,0,0.1 ) 50%, rgba( 0,0,0,0.9 ) 75%); background-image: -moz-linear-gradient(left, rgba( 0,0,0,0.9 ) 25%, rgba( 0,0,0,0.1 ) 50%, rgba( 0,0,0,0.9 ) 75%); background-image: -ms-linear-gradient(left, rgba( 0,0,0,0.9 ) 25%, rgba( 0,0,0,0.1 ) 50%, rgba( 0,0,0,0.9 ) 75%); background-image: -o-linear-gradient(left, rgba( 0,0,0,0.9 ) 25%, rgba( 0,0,0,0.1 ) 50%, rgba( 0,0,0,0.9 ) 75%); background-image: linear-gradient(to right, rgba( 0,0,0,0.9 ) 25%, rgba( 0,0,0,0.1 ) 50%, rgba( 0,0,0,0.9 ) 75%); -webkit-animation: move_eye 4s linear 0s infinite alternate; -moz-animation: move_eye 4s linear 0s infinite alternate; -o-animation: move_eye 4s linear 0s infinite alternate; animation: move_eye 4s linear 0s infinite alternate; } @-webkit-keyframes move_eye { from { margin-left:-20%; } to { margin-left:100%; } } @-moz-keyframes move_eye { from { margin-left:-20%; } to { margin-left:100%; } } @-o-keyframes move_eye { from { margin-left:-20%; } to { margin-left:100%; } } @keyframes move_eye { from { margin-left:-20%; } to { margin-left:100%; } } "},"css/cases/04_.html":{"url":"css/cases/04_.html","title":"箭头旋转","keywords":"","body":"箭头旋转 .recharge-details .arrow { position: relative; } .recharge-details .arrow:after { position: absolute; right: 15px; top: 18px; width: 0; height: 0; content: \"\"; border-width: 6px 6px 0 6px; border-style: solid; border-color: #fff transparent; -webkit-transition: all 0.25s; -moz-transition: all 0.25s; -ms-transition: all 0.25s; -o-transition: all 0.25s; transition: all 0.25s; } .recharge-details .arrow:before { position: absolute; right: 13px; top: 18px; width: 0; height: 0; content: \"\"; border-width: 8px 8px 0 8px; border-style: solid; border-color: #333 transparent; -webkit-transition: transform 0.25s; -moz-transition: transform 0.25s; -ms-transition: transform 0.25s; -o-transition: transform 0.25s; transition: transform 0.25s; } .recharge-details .arrow.active:after { top: 20px; -webkit-transform: rotate(180deg); -moz-transform: rotate(180deg); -ms-transform: rotate(180deg); -o-transform: rotate(180deg); transform: rotate(180deg); } .recharge-details .arrow.active:before { -webkit-transform: rotate(180deg); -moz-transform: rotate(180deg); -ms-transform: rotate(180deg); -o-transform: rotate(180deg); transform: rotate(180deg); } $(this) .children(\"div.arrow\") .toggleClass(\"active\"); "},"css/cases/05_.html":{"url":"css/cases/05_.html","title":"垂直居中","keywords":"","body":"垂直居中 div { width: 50%; margin: 0 auto; height: 200px; line-height: 200px; background-color: antiquewhite; text-align: center; } div img { vertical-align: middle; display: inline-block; /*margin: 0 0 -20px 0;*/ } 文字与图标居中 "},"css/cases/06_.html":{"url":"css/cases/06_.html","title":"线性渐变色","keywords":"","body":"线性渐变色 background: -webkit-linear-gradient(#ff71e0,#fffdfe, #ff71e0); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(#ff71e0, #fffdfe, #ff71e0); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(#ff71e0,#fffdfe, #ff71e0); /* Firefox 3.6 - 15 */ background: linear-gradient(#ff71e0,#fffdfe, #ff71e0); /* 标准的语法 */ "},"css/cases/07_.html":{"url":"css/cases/07_.html","title":"三角符号","keywords":"","body":"三角符号 .trangle-up { width: 0; height: 0; border-left: 30px solid transparent; border-right: 30px solid transparent; border-top: 30px solid black; } .trangle-down { width: 0; height: 0; border-left: 30px solid transparent; border-right: 30px solid transparent; border-bottom: 30px solid black; } "},"css/cases/08_.html":{"url":"css/cases/08_.html","title":"文字|内容超过部分隐藏","keywords":"","body":"文字|内容超过部分隐藏 .text1 { width: 200px; overflow: hidden; text-overflow: ellipsis; -o-text-overflow: ellipsis; -webkit-text-overflow: ellipsis; -moz-text-overflow: ellipsis; white-space: nowrap; } 热卖精选：从子频道（服饰鞋包，亲子，居家，美妆）档期里面挑选出来，库存大于30%的高信价比商品list，数量为50个 解释 width：设置可是区域的宽度 overflow:hidden;设置超出父元素部分隐藏 text-overflow:ellipsis:文字溢出部分显示为 三个点 white-space:nowrap;设置段落中的文本不会换行 -webkit-line-clamp：2；设置段落中的文本的，需要换的行数 display:-webkit-box;设置子元素跟随父元素改变大小 word-break:break-all;在恰当的断字点进行换行： .item-text-city { font-size: 11pt; font-weight: 100; width: 450rpx; overflow: hidden; text-overflow: ellipsis; -o-text-overflow: ellipsis; -webkit-text-overflow: ellipsis; -moz-text-overflow: ellipsis; white-space: nowrap; } "},"css/cases/09_.html":{"url":"css/cases/09_.html","title":"兼容前缀","keywords":"","body":"兼容前缀 -moz-( 代表firefox浏览器私有属性 ) -ms-( 代表IE浏览器私有属性 ) -o-( 代表opera私有属性 ) -webkit-( 代表chrome、safari私有属性 ) "},"css/cases/10_.html":{"url":"css/cases/10_.html","title":"边框(border-images)","keywords":"","body":"边框(border-images) （border-images）在谷歌浏览器和火狐浏览器上面得到很好的支持 语法： border-image ： none | [ | ]{1,4} [ / {1,4} ]? [ stretch | repeat | round ]{0,2} 相关属性： border-image: border-top-image , border-right-image , border-bottom-image , border-left-image border-corner-image: border-top-left-image , border-top-right-image , border-bottom-left-image , border-bottom-right-image -webkit-border-image: url(../images/1.jpg) 0 12 0 12 stretch stretch; -moz-border-image: url(../images/1.jpg) 0 12 0 12 stretch stretch; border-image: source slice width outset repeat; 使用方法: source （用于指定要用于绘制边框的图像的位置） slice （图像边界向内偏移） width (图像边界的宽度) outset (用于指定在边框外部绘制 border-image-area 的量) repeat (这个例子演示了如何创建一个border-image 属性的按钮。) "},"vue/components/":{"url":"vue/components/","title":"components","keywords":"","body":"components "},"vue/components/props.html":{"url":"vue/components/props.html","title":"组件传值_props","keywords":"","body":"组件传值_props 父与子 父传值给子组件 父组件 import Thread from './Thread.vue' export default { name: 'ThreadSection', data(){ return{ phone: '15868600329' } }, components: { Thread }, } 子组件 {{phone}} export default { name: 'Thread', props: { active: Boolean, phone: Number } } "},"vue/router/":{"url":"vue/router/","title":"router","keywords":"","body":"router 路由懒加载 "},"vue/router/lazy_loading.html":{"url":"vue/router/lazy_loading.html","title":"路由懒加载","keywords":"","body":"路由懒加载 loading "},"vue/vuex/":{"url":"vue/vuex/","title":"vuex","keywords":"","body":"VUE "},"vue/plugin/":{"url":"vue/plugin/","title":"plugin","keywords":"","body":"plugin 插件注册 import PickerComponent from \"./picker.vue\"; let $vm; export default { install(Vue, options) { if (!$vm) { const pickerPlugin = Vue.extend(PickerComponent); $vm = new pickerPlugin({ el: document.createElement(\"div\"), }); document.body.appendChild($vm.$el); } $vm.showValue = false; let picker = { show(options) { console.log(15) $vm.showValue = true; }, hide() { document.body.removeChild($vm.$el); }, }; if (!Vue.$picker) { Vue.$picker = picker; } Vue.mixin({ created() { this.$picker = Vue.$picker; }, }); }, }; "},"vue/plugin/picker/":{"url":"vue/plugin/picker/","title":"picker","keywords":"","body":"picker export default { name: \"my-picker\", props: { showValue: Boolean, }, }; @import url(\"../../assets/common.less\"); @import url(\"../../../node_modules/animate.css/animate.min.css\"); .my-picker { .my-picker-bg { position: absolute; background-color: rgba(0, 0, 0, 0.5); } .my-picker-container { position: absolute; bottom: 0; width: 100%; height: 45vh; background-color: #fff; } } // 设置动画执行时间 .my-picker-container { animation-duration: 250ms; animation-timing-function: linear; } .my-picker-bg { animation-duration: 260ms; animation-timing-function: linear; } "},"ubuntu/serves/":{"url":"ubuntu/serves/","title":"服务器生存指南","keywords":"","body":"服务器生存指南 "},"ubuntu/serves/0_ftp.html":{"url":"ubuntu/serves/0_ftp.html","title":"ftp 之路","keywords":"","body":"安装vsftp sudo apt-get update sudo apt-get install vsftpd 创建ftp文件夹 sudo mkdir *ftp文件夹* 更改文件夹权限 sudo chmod -R 777 *ftp文件夹* 创建FTP用户 # 创建用户并指定目录 sudo useradd -d *ftp文件夹*/ 用户名 # 设置ftp用户的密码 sudo passwd ftp用户名 设置相关配置 sudo vim /etc/vsftpd.conf # 添加如下内容 userlist_deny=NO userlist_enable=YES # 允许登录的用户 userlist_file=/etc/allowed_users seccomp_sandbox=NO # 允许访问的文件夹 local_root=*ftp文件夹* local_enable=YES write_enable=YES # 使用utf8 utf8_filesystem=YES 修改 /etc/pam.d/vsftpd sudo vim /etc/pam.d/vsftpd # 在auth required pam_shells.so前加# 操作命令 # 启动停止重启服务 sudo /etc/init.d/vsftpd start sudo /etc/init.d/vsftpd stop sudo /etc/init.d/vsftpd restart # 查看服务状态 service vsftpd status 访问ftp服务器 # bash 访问 sudo ftp 127.0.0.1 # 浏览器访问 ftp://127.0.0.1 # 或者 ftp//localhost 注意点 1.服务器需要设置安全策略组权限 2.ftp文件夹注意设置权限 参考 最简单靠谱的vsftpd安装指南（Ubuntu16.04） Ubuntu 16.04 安装ftp服务器传输文件 "},"ubuntu/serves/01_nginx/1_nginx.html":{"url":"ubuntu/serves/01_nginx/1_nginx.html","title":"nginx 安装","keywords":"","body":"说明 安装nginx，是为了方便安装wordpress； 所以在安装过程中，将nginx的站点路径设置指向wordPress所在目录。 安装nginx sudo apt-get install nginx 配置nginx # 进入编辑模式 sudo vim /etc/nginx/sites-available/default # 将default中内容改为以下内容 # include snippets/snakeoil.conf; root /var/www/html; # Add index.php to the list if you are using PHP # index index.html index.htm index.nginx-debian.html; index index.php location ~ \\.php$ { include snippets/fastcgi-php.conf; # # # With php7.0-cgi alone: # fastcgi_pass 127.0.0.1:9000; # # With php7.0-fpm: fastcgi_pass unix:/run/php/php7.0-fpm.sock; } # 保存退出 运行nginx # 配置快捷启动方式 sudo vim /etc/init.d/nginx //创建启动脚本 sudo chmod a+x /etc/init.d/nginx //增加执行权限 # 启动-停止-重启 sudo /etc/init.d/nginx start //启动 sudo /etc/init.d/nginx stop //停止 sudo /etc/init.d/nginx restart //重启 参考文章 Ubuntu下Nginx安装 "},"ubuntu/serves/01_nginx/2_instruction.html":{"url":"ubuntu/serves/01_nginx/2_instruction.html","title":"指令","keywords":"","body":"查看nginx进程：nginx的进程由主进程和工作进程组成 ps -ef|grep nginx 启动nginx service nginx start # 平滑启动nginx kill -HUP `cat /var/run/nginx.pid` # or nginx -s reload 停止nginx # 完美停止nginx kill -TERM `cat /var/run/nginx.pid` # or kill -INT `cat /var/run/nginx.pid` # 完美停止工作进程 kill -WINCH `cat /var/run/nginx.pid` # 强制停止nginx pkill -9 nginx # 停止nginx的命令 nginx -s stop 检查对nginx.conf文件的修改是否正确 nginx -t -c /etc/nginx/nginx.conf 或者 nginx -t 查看nginx的版本信息 nginx -v "},"ubuntu/serves/02_mysql/1_mysql.html":{"url":"ubuntu/serves/02_mysql/1_mysql.html","title":"mysql 安装","keywords":"","body":"安装mysql # 检查系统是否已经安装mysql which mysql # /user/bin/mysql # 安装mysql # 安装时根据安装提示设置相关mysql sudo apt-get install mysql-server mysql-client # 测试是否安装成功 sudo netstat -tap | grep mysql # 登录mysql mysql -u root -p # 设置密码 mysqladmin -u root password \"new_password\"; 登录 mysql -u 用户名 -p Enter password: 输入密码 操控数据库 以下命令需要登录mysql之后，才能执行 # 显示所有数据库 show databases; +--------------------+ | Database | +--------------------+ | information_schema | | WP | | mysql | | performance_schema | | sys | +--------------------+ 5 rows in set (0.00 sec) # 创建数据库 create database 数据库名 # 删除数据库 drop database 数据库名 参考 MySQL 教程 Ubuntu 16.04 mysql安装配置 指令合集 "},"ubuntu/serves/02_mysql/2_instruction.html":{"url":"ubuntu/serves/02_mysql/2_instruction.html","title":"指令","keywords":"","body":"登录 mysql -u 用户名 -p => 回车 => 输入密码 创建数据库 create database 库名; 导入备份数据 source 数据路径; "},"ubuntu/serves/03_WordPress.html":{"url":"ubuntu/serves/03_WordPress.html","title":"WordPress 之路","keywords":"","body":"WordPress之路 安装mysql 安装ftp 安装nginx ubuntu 16.04 LTS下php环境配置 接下来开始WP的安装了 首先下载源代码 wget https://cn.wordpress.org/wordpress-4.8.1-zh_CN.tar.gz "},"ubuntu/serves/04_GRUN.html":{"url":"ubuntu/serves/04_GRUN.html","title":"GRUN 之路","keywords":"","body":"GRUN之路 编辑 #进入GRUN sudo vim /etc/default/grub # 在文件中。将相关内容设置为如下内容 GRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash\" GRUB_CMDLINE_LINUX=\"acpi=off\" 保存修改&配置到系统 sudo update-grup apci=off 禁用部分设备硬件，提高系统响应速度。特别是使用HHD作为系统盘的情况下。效果显著 nomodeset 最新的内核已经把视频模式设置嵌入内核中，所以所有显卡硬件程序的指定时钟和寄存器当图形服务器启动时在内核进行而不是图形设备运行，这使得我们在启动时可以看到不闪的和高分辨率的好看的启动界面，但是，在某些视频卡它不能正常工作而现实黑屏，增加nomodeset参数则告诉内核不要加载显卡而用BIOS模式直到图形界面运行 The newest kernels have moved the video mode setting into the kernel. So all the programming of the hardware specific clock rates and registers on the video card happen in the kernel rather than in the X driver when the X server starts.. This makes it possible to have high resolution nice looking splash (boot) screens and flicker free transitions from boot splash to login screen. Unfortunately, on some cards this doesnt work properly and you end up with a black screen. Adding the nomodeset parameter instructs the kernel to not load video drivers and use BIOS modes instead until X is loaded. quiet 内核启动时候简化提示信息 splash 启动的时候使用图形化的进度条代替init的字符输出过程 详细代码 # If you change this file, run 'update-grub' afterwards to update # /boot/grub/grub.cfg. # For full documentation of the options in this file, see: # info -f grub -n 'Simple configuration' GRUB_DEFAULT=0 GRUB_HIDDEN_TIMEOUT=0 GRUB_HIDDEN_TIMEOUT_QUIET=true GRUB_TIMEOUT=10 GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian` GRUB_CMDLINE_LINUX_DEFAULT=\"quiet\" GRUB_CMDLINE_LINUX=\"acpi=on\" # Uncomment to enable BadRAM filtering, modify to suit your needs # This works with Linux (no patch required) and with any kernel that obtains # the memory map information from GRUB (GNU Mach, kernel of FreeBSD ...) #GRUB_BADRAM=\"0x01234567,0xfefefefe,0x89abcdef,0xefefefef\" # Uncomment to disable graphical terminal (grub-pc only) #GRUB_TERMINAL=console # The resolution used on graphical terminal # note that you can use only modes which your graphic card supports via VBE # you can see them in real GRUB with the command `vbeinfo' #GRUB_GFXMODE=640x480 # Uncomment if you don't want GRUB to pass \"root=UUID=xxx\" parameter to Linux #GRUB_DISABLE_LINUX_UUID=true # Uncomment to disable generation of recovery mode menu entries #GRUB_DISABLE_RECOVERY=\"true\" # Uncomment to get a beep at grub start #GRUB_INIT_TUNE=\"480 440 1\" "},"ubuntu/serves/05_L2TP_Client.html":{"url":"ubuntu/serves/05_L2TP_Client.html","title":"L2TP Client 之路","keywords":"","body":"L2TP Client之路 添加源 sudo add-apt-repository ppa:nm-l2tp/network-manager-l2tp 更新缓存 sudo apt-get update 安装network-manager-l2tp sudo apt install network-manager-l2tp 安装UI sudo apt install network-manager-l2tp-gnome 配置 配置网关:,,, 设置用户名: * "},"ubuntu/serves/06_docker.html":{"url":"ubuntu/serves/06_docker.html","title":"docker之路","keywords":"","body":"docker之路 前端环境开发 How to use Docker containers for Vue.js applications win10运行linux容器 资料 Docker-no-Windows-vs-Docker-no-Linux Docker配置本地镜像与容器的存储位置 搜索条件:docker OSType Development mode docker run --rm -v $(pwd):/src -w /src -p 8080:8080 node:6 bash -c \"npm install && npm run dev\" Build for production docker run --rm -v $(pwd):/src -w /src node:6 bash -c \"npm install && npm run build\" Command breakout --rm tells Docker to delete the container when it is stopped (otherwise you’ll end up with a new container every time you start or build your app). node:6 is the name of the image. -v .:/src mounts the current directory (.) at the root of the container in a folder named /src. This is very similar to a virtual drive (Windows) or a virtual disk (Un*x/OSX). -w /src sets the container’s working directory (where commands will be executed) at the folder we just created. -p 8080:8080 opens the port 8080 of the container to your local browser (needed by Webpack dev server) bash -c \"...\" starts a new bash instance inside the container, useful for such complicated bash commands using an && that may be misinterpreted by your system’s shell. "},"ubuntu/serves/07_mongodb.html":{"url":"ubuntu/serves/07_mongodb.html","title":"mongodb之路","keywords":"","body":"mongodb之路 1、添加 MongoDB 公共GPG钥匙。 sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv EA312927 2、创建列表文件，官方ubuntu16.04安装代码如下： echo \"deb http://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.2 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-3.2.list 因为我们要替换国内的镜像，所以这里就不能使用 repo.mongodb.org 作下载地址了。把官方这句替换如下： echo \"deb http://mirrors.aliyun.com/mongodb/apt/ubuntu xenial/mongodb-org/3.2 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-3.2.list 3、重新加载本地包数据库 sudo apt-get update 4、安装MongoDB sudo apt-get install -y mongodb-org 5、启动MongoDB sudo service mongod start 6、打开MongoDB sudo mongo "},"ubuntu/instruction.html":{"url":"ubuntu/instruction.html","title":"常用指令","keywords":"","body":"常用指令 linux修改文件所属用户和组 使用chown命令可以修改文件或目录所属的用户： 命令：chown 用户 目录或文件名 例如：chown qq /home/qq (把home目录下的qq目录的拥有者改为qq用户) 使用chgrp命令可以修改文件或目录所属的组： 命令：chgrp 组 目录或文件名 例如：chgrp qq /home/qq (把home目录下的qq目录的所属组改为qq组) "},"ubuntu/software/":{"url":"ubuntu/software/","title":"常用软件安装","keywords":"","body":"常用软件安装 通用功能 添加软件源： sudo apt-get-repository ppa:源 更换软件源 sed -i 's/archive.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.list apt-get update Ubuntu 更换阿里云软件源 # 备份 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak # 修改 sed -i 's/cn.archive.ubuntu.com/mirrors.aliyun.com/g' /etc/apt/sources.list # 更新 sudo apt-get update 挂载共享文件 1.打开VirtualBox,设置虚拟机的共享文件 2.VirtualBOX控制台=>设备=>安装增强功能 3.打开ubuntu的终端(Ctrl + Alt + T)=>输入 [ mount -t vboxsf 共享文件夹名 挂载路径 ] mount -t vboxsf wwww /mnt/www 安装搜狗输入法 http://pinyin.sogou.com/linux/help.php 安装sublime http://www.cnblogs.com/shiddong/p/6106504.html vagrant安装 $ sudo dpkg -i *.deb //安装软件 //如果是由于软件依赖问题的话,执行下列的命令，然后再次运行安装命令 $ sudo apt-get -f install chrome安装 下载源：$ sudo wget https://repo.fdzh.org/chrome/google-chrome.list -P /etc/apt/sources.list.d/ 导入公钥：$ wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add - 更新：$ sudo apt-get update 下载并安装：$ sudo apt-get install google-chrome-stable 启动： $ /usr/bin/google-chrome-stable wine安装 1、安装源 sudo add-apt-repository ppa:wine/wine-builds sudo apt-get update 2、安装wine sudo apt-get install --install-recommends wine-staging sudo apt-get install winehq-staging 3、卸载wine #1).卸载wine主程序，在终端里输入： sudo apt-get remove --purge wine #2).然后删除wine的目录文件： rm -r ~/.wine #3).卸载残留不用的软件包： sudo apt-get autoremove 4、终端中输入wine，检测是否安装完成。 shadowsocks-qt5安装 #1.安装源 sudo add-apt-repository ppa:hzwhuang/ss-qt5 sudo apt-get update #2.安装shadowsocks-qt5 sudo apt-get install shadowsocks-qt5 显示网速 1.安装源 sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitor sudo apt-get update 2.安装indicator-sysmonitor sudo apt-get install indicator-sysmonitor 网速限制 1.wondershaper地址 #2.下载 git clone git@github.com:magnific0/wondershaper.git cd wondershaper #3.使用 #(1) 查看网络使用接口 ifconfig or ip addr show #(2)示例 # 设置 sudo ./wondershaper -a wlp4s0 -u 4096 -d 8192 # 清除设置 sudo ./wondershaper -c -a wlp4s0 #(3)说明 -u 设置 上行网速（单位：Mbps） -d 设置 下行网速（单位：Mbps） steam 文档：http://blog.csdn.net/jianwen_hi/article/details/51843385 1.记录第一种简易安装的方式： sudo add-apt-repository multiverse sudo apt update sudo apt install steam yarn curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add - echo \"deb https://dl.yarnpkg.com/debian/ stable main\" | sudo tee /etc/apt/sources.list.d/yarn.list sudo apt-get update && sudo apt-get install yarn install software 下载源码安装包 wget http://nodejs.org/dist/v0.12.0/node-v0.12.0.tar.gz //这里我是直接下载好文件放到指定目录下 解压源码安装包 tar xvf node-v0.12.0.tar.gz 如果服务器没有源码编译环境， 先要下载一些编译环境，等待几分钟。 设置启动区位置 gsettings set com.canonical.Unity.Launcher launcher-position Bottom 声卡设置 # 解决usb耳机声音播放的问题 gnome-alsamixer alsamixer pavucontrol(终极方案) sudo yum install gcc gcc-c++ 进入已经解压的的文件夹 cd node-v0.12.0 开始配置编译 ./configure make 编译成功然后安装 sudo make install 软件源 deb http://mirrors.aliyun.com/ubuntu trusty main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu trusty-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu trusty-backports main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu trusty-security main restricted universe multiverse "},"git/git.html":{"url":"git/git.html","title":"git 命令","keywords":"","body":"git命令 添加远程仓库 git remote add origin git@github.com:seamong/gitbook git push -u origin master 本地创建远程分支 git push origin : 本地删除远程分支 git push origin : 本地分支绑定远程分支 git branch --set-upstream-to=origin/ 创建本地分支 git checkout -b 删除本地分支 git branch -D 配置ssh ssh-keygen -t rsa -b 4096 -C \"****@****.****\" 添加远程仓库 git remote add origin https://github.com/**/**.git git push -u origin master 回退一次版本(强制) git reset --hard HEAD^ "},"git/push.html":{"url":"git/push.html","title":"git~push","keywords":"","body":"git~push 提交代码出现错误时，解决办法 git add . # 订单以及地址样式修改 git commit -m \"\" //[test 4dffb5e] index git push origin test 强制更新 git pull -f origin test //该命令 无视本地文件修改.直接将远程仓库的代码覆盖本地文件 "},"git/faq.html":{"url":"git/faq.html","title":"git~F.A.Q","keywords":"","body":"git~F.A.Q 在git的一般使用中，如果发现错误的将不想提交的文件add进入index之后，想回退取消，则可以使用命令：git reset HEAD ...，同时git add完毕之后，git也会做相应的提示，比如： 引用 Changes to be committed: (use \"git reset HEAD...\" to unstage) # new file: Test.scala git reset [--hard|soft|mixed|merge|keep] [或HEAD]：将当前的分支重设（reset）到指定的或者HEAD（默认，如果不显示指定commit，默认是HEAD，即最新的一次提交），并且根据[mode]有可能更新index和working directory。 下面列出一些git reset的典型的应用场景： A) 回滚add操纵 引用 # 编辑文件frotz.c, filfre.c，做了些更改，并把更改添加到了index edit git add frotz.c filfre.c # 查看邮件，发现某人要你pull，有一些改变需要你merge下来 mailx # 然而，你已经把index搞乱了，因为index同HEAD commit不匹配了， # 但是你知道，即将pull的东西不会影响已经修改的frotz.c和filfre.c， # 因此你可以revert这两个文件的改变。revert后， # 那些改变应该依旧在working directory中，因此执行git reset。 git reset # 然后，执行了pull之后，自动merge， # frotz.c和filfre.c这些改变依然在working directory中。 $ git pull git://info.example.com/ nitfol (4) B) 回滚最近一次commit 引用 git commit ... # 当提交了之后，你又发现代码没有提交完整， # 或者你想重新编辑一下提交的comment， # 执行git reset --soft HEAD^， # 让working tree还跟reset之前一样，不作任何改变。 # HEAD^指向HEAD之前最近的一次commit。 git reset --soft HEAD^ # 对working tree下的文件做修改 edit # 然后使用reset之前那次commit的注释、作者、日期等信息重新提交。 # 注意，当执行git reset命令时，git会把老的HEAD拷贝到文件.git/ORIG_HEAD中， # 在命令中可以使用ORIG_HEAD引用这个commit。 # commit 命令中 -a 参数的意思是告诉git， # 自动把所有修改的和删除的文件都放进stage area，未被git跟踪的新建的文件不受影响。 # commit命令中-c 或者 -C 意思是拿 # 已经提交的commit对象中的信息（作者，提交者，注释，时间戳等）提交， # 那么这条commit命令的意思就非常清晰了，把所有更改的文件加入stage area， # 并使用上次的提交信息重新提交。 git commit -a -c ORIG_HEAD C) 回滚最近几次commit，并把这几次commit放到叫做topic的branch上去。 引用 # 你已经提交了一些commit，但是此时发现这些commit还不够成熟， # 不能进入master分支，但你希望在新的branch上润色这些commit改动。 # 因此执行了git branch命令在当前的HEAD上建立了新的叫做 topic/wip的分支。 git branch topic/wip # 然后回滚master branch上的最近三次提交。 # HEAD~3指向当前HEAD-3个commit的commit， # git reset --hard HEAD~3即删除最近的三个commit #（删除HEAD, HEAD^, HEAD~2），将HEAD指向HEAD~3。 git reset --hard HEAD~3 # 切换到`topic/wip` 分支 $ git checkout topic/wip D) 永久删除最后几个commit git commit ... # 最后三个commit（即HEAD, HEAD^和HEAD~2）提交有问题，你想永久删除这三个commit。 git reset --hard HEAD~3 (1) E) 回滚merge和pull操作 引用 # 从origin拉下来一些更新，但是产生了很多冲突， # 你暂时没有这么多时间去解决这些冲突，因此你决定稍候有空的时候再重新pull。 $ git pull Auto-merging nitfol CONFLICT (content): Merge conflict innitfol Automatic merge failed; fix conflicts andthen commit the result. # 由于pull操作产生了冲突，因此所有pull下来的改变尚未提交， # 仍然再stage area中， # 这种情况下git reset --hard与 git reset --hard HEAD意思相同， # 即都是清除index和working tree中被搞乱的东西。 $ git reset --hard # 将topic/branch合并到当前的branch，这次没有产生冲突，并且合并后的更改自动提交。 $ git pull . topic/branch Updating from 41223... to 13134... Fast-forward # 但是此时你又发现将topic/branch合并过来为时尚早， # 因此决定退滚merge，执行git reset --hard ORIG_HEAD回滚刚才的pull/merge操作。 # 说明：前面讲过，执行git reset时， # git会把reset之前的HEAD放入.git/ORIG_HEAD文件中， # 命令行中使用ORIG_HEAD引用这个commit。 # 同样的，执行pull和merge操作时， # git都会把执行操作前的HEAD放入ORIG_HEAD中，以防回滚操作。 $ git reset --hard ORIG_HEAD F) 在被污染的working tree中回滚merge或者pull 引用 # 即便你已经在本地更改了一些你的working tree， # 你也可安全的git pull， # 前提是你知道将要pull的内容不会覆盖你的working tree中的内容。 $ git pull Auto-merging nitfol Merge made by recursive. nitfol | 20 +++++---- ... # git pull完后，你发现这次pull下来的修改不满意， # 想要回滚到pull之前的状态，从前面的介绍知道， # 我们可以执行git reset --hard ORIG_HEAD， # 但是这个命令有个副作用就是清空你的working tree， # 即丢弃你的本地未add的那些改变。为了避免丢弃working tree中的内容， # 可以使用git reset --merge ORIG_HEAD， # 注意其中的--hard 换成了--merge， # 这样就可以避免在回滚时清除working tree。 $ git reset --merge ORIG_HEAD (2) G) 被中断的工作流程 在实际开发中经常出现这样的情形：你正在开发一个大的feature，此时来了一个紧急的bug需要修复，但是目前在working tree中的内容还没有成型，还不足以commit，但是你又必须切换的另外的branch去fix bug。请看下面的例子 $ git checkout feature ;# you were workingin \"feature\" branch and $ work work work ;#got interrupted # 这次属于临时提交，因此随便添加一个临时注释即可。 $ git commit -a -m \"snapshot WIP\" $ git checkout master $ fix fix fix $ git commit ;# commit with real log $ git checkout feature # 这次reset删除了WIP commit，并且把working tree设置成提交WIP快照之前的状态。 $ git reset --soft HEAD^ ;# go back to WIPstate # 此时，在index中依然遗留着“snapshot WIP”提交时所做的uncommit changes， # git reset将会清理index成为尚未提交\"snapshot WIP\"时的状态便于接下来继续工作。 $ git reset (H) Reset单独的一个文件 假设你已经添加了一个文件进入index，但是而后又不打算把这个文件提交，此时可以使用git reset把这个文件从index中去除。 # 把文件frotz.c从index中去除， $ git reset -- frotz.c # 把index中的文件提交 $ git commit -m \"Commit files inindex\" # 再次把frotz.c加入index $ git add frotz.c (I) 保留working tree并丢弃一些之前的commit 假设你正在编辑一些文件，并且已经提交，接着继续工作，但是现在你发现当前在working tree中的内容应该属于另一个branch，与这之前的commit没有什么关系。此时，你可以开启一个新的branch，并且保留着working tree中的内容。 git tag start git checkout -b branch1 edit # 这次是把在branch1中的改变提交了。 git commit ... edit # 此时发现，之前的提交不属于这个branch，此时你新建了branch2，并切换到了branch2上。 git checkout -b branch2 # 此时你可以用reset --keep把在start之后的commit清除掉，但是保持working tree不变。 git reset --keep start "},"node/0.html":{"url":"node/0.html","title":"node","keywords":"","body":"node "},"node/01_nodejs_phantomjs_nodemailer.html":{"url":"node/01_nodejs_phantomjs_nodemailer.html","title":"nodejs+phantomjs+nodemailer","keywords":"","body":"功能 每天定时截图，并把截到的图片自动通过邮件发送。 说明 代码注释已经非常详细，就不多做说明，需要的朋友自己查看代码即可，主文件Mail.js，截图文件capturePart1.js，capturePart2.js，capturePart3.js，这里只展示了capturePart1.js其他两个类似。值得注意的是有登录权限的网站一定要设置Cookie，需要截取高质量图片的话截取时间一定设置长一些。 Mail.js * 定时发送邮件功能说明： * node.js必备安装模块：node_modules-->phantomjs，nodemailer，node-schedule，moment * 涉及JS文件：route-->mail.js，public-->js-->capturePart1.js，capturePart2.js，capturePart3.js * 截图保存地址：public-->images-->mainPage.jpeg(1600*4200) * 截图url：http://www.***********.com * 程序主要思路： * （1）phantomjs截图-->参照http://phantomjs.org/ * （2）nodemailer发送邮件-->参照https://www.npmjs.com/package/nodemailer * （3）node-schedule定时-->参照https://www.npmjs.com/package/node-schedule * 注意： * 改变发件服务器请修改SMTP * 改变收件人请修改变量receiver * 改变邮件内容请修改变量html * 改变邮件附加图片和附件请修改attachments * 改变截图功能请修改public-->js-->server.js * 改变定时功能请修改变量rule * ------Sweety //组件引入开始 var schedule = require(\"node-schedule\"); var path = require('path'); var childProcess = require('child_process'); var phantomjs = require('phantomjs'); var nodemailer = require(\"nodemailer\"); var moment = require(\"moment\"); //组件引入结束 /*--------------------------------------------------------------------------------------------------------------------------------------------*/ //变量定义开始 var today; //今天开始时间 var binPath = phantomjs.path; //获取phantomjs.exe路径 var jsPath = process.cwd()+\"/public/js/\"; //获取server.js所在目录 var childArgs; //capturePart3(); //capturePart1(); //变量定义结束 /*--------------------------------------------------------------------------------------------------------------------------------------------*/ //主程序开始 var rule = new schedule.RecurrenceRule(); //schedule定时器 rule.hour = 11; rule.minute = 0; rule.second = 0; //定时器规则设定（每天11点触发事件） var j = schedule.scheduleJob(rule, function(){ var now = moment(); today = now.clone().add(-1, 'days').format('YYYY-MM-DD'); capturePart1(); //触发截图事件(邮件发送功能包含在截图事件里边) }); //主程序结束 /*---------------------------------------------------------------------------------------------------------------------------------------------*/ //phantomjs截图开始(第一张) function capturePart1(){ childArgs = [ path.join(jsPath, 'serverPart1.js'), //server.js ' https://www.hao123.com ' //要截图的url ]; childProcess.execFile(binPath, childArgs, function(err, stdout, stderr) { if(err) { console.log(err); //打印错误信息 }else{ console.log(\"Captured Part1 Successful !!\"); //打印正确信息 capturePart2(); } }); } //phantomjs截图结束(第一张) //phantomjs截图开始(第二张) function capturePart2(){ childArgs = [ path.join(jsPath, 'serverPart2.js'), //server.js路径 'https://www.hao123.com ' //要截图的url ]; childProcess.execFile(binPath, childArgs, function(err, stdout, stderr) { if(err) { console.log(err); //打印错误信息 }else{ console.log(\"Captured Part2 Successful !!\"); //打印正确信息 capturePart3(); } }); } //phantomjs截图结束(第二张) //phantomjs截图开始(第三张) function capturePart3(){ childArgs = [ path.join(jsPath, 'serverPart3.js'), //server.js路径 ' https://www.hao123.com ' //要截图的url ]; childProcess.execFile(binPath, childArgs, function(err, stdout, stderr) { if(err) { console.log(err); //打印错误信息 }else{ console.log(\"Captured Part3 Successful !!\"); //打印正确信息 sent(); // 触发发送邮件事件 } }); } //phantomjs截图结束(第三张) /*-------------------------------------------------------------------------------------------------------------------------------------------------*/ //nodemailer发送邮件开始 function sent(){ var imgPart1 = fs.readFileSync(process.cwd()+\"/public/images/mainPagePart1.jpeg\"); //图片来源 var imgPart2 = fs.readFileSync(process.cwd()+\"/public/images/mainPagePart2.jpeg\"); //图片来源 var imgPart3 = fs.readFileSync(process.cwd()+\"/public/images/mainPagePart3.jpeg\"); //图片来源 var smtpTransport = nodemailer.createTransport(\"SMTP\",{ //邮件SMTP设定（发送邮箱服务器必须开启SMTP） host: \"smtp.xxxxx.com\", // 主机 secureConnection: false, // 不使用 SSL port: 587, // SMTP 端口 auth: { user: \"xxxxx@xxxx.com\", //用户名 pass: \"xxxxxx\" //密码 } }); var html = '' + 'XX好:'+ '&nbsp;&nbsp;下面为【XXXX】日报汇报（'+today+'）的内容,请参考' + '&nbsp;&nbsp;（日报详细信息请点击此处登陆查看）'+ '' + ''+ ''+ '';//邮件内容（html代码），img唯一指定地址对应cid（见mailOptions设定） var receiver = \"xxx@xxx.com\";//收件人列表 var cc = \"xxxx@xxxx.com,xxx@xxx.com,xxx@xxxx.com\"; //抄送人列表 var bcc = \"xxx@xxxx.com,xxx@xxxx.com\"; //密抄送人列表 var mailOptions = { //邮件内容选项设定 from: \"\", //发件地址 //to: \"xxx@xxxx.com\", to: receiver, //收件人 cc:cc, //抄送人 bcc:bcc, //密抄送人 subject:\"【XXXX】日报汇报（\"+today+\"）\", //邮件主题 text: \"【XXXX】日报汇报（\"+today+\"）\", // plaintext body html:html, //html内容 attachments: [ { filename: 'mainPagePart1.jpeg', //图片名称 contents: imgPart1, //图片来源 cid: 'img1' //插入图片标识 },{ filename: 'mainPagePart2.jpeg', //图片名称 contents: imgPart2, //图片来源 cid: 'img2' //插入图片标识 },{ filename: 'mainPagePart3.jpeg', //图片名称 contents: imgPart3, //图片来源 cid: 'img3' //插入图片标识 } ] }; smtpTransport.sendMail(mailOptions, function(error, response){//发送邮件 if(error){ console.log(error); //打印错误信息 }else{ console.log(\"Sent Successful !!\"); //打印正确信息 } }); } //nodemailer发送邮件结束 function changeData(){ } /*---------------------------------------------------------------------------------------------------------------------------------------------*/ capturePart1.js //phantomjs截图 var page = require('webpage').create(), system = require('system'), address; page.viewportSize = { width:1920, height: 1080}; page.clipRect = { top: 200, left: 210, width: 1680, height: 1530 }; page.customHeaders={\"Cookie\":\"koa:sess=e*******=;koa:sess.sig=pjadZtLAVtiO6-Haw1vnZZWrRm8\"}; if (system.args.length === 1) { phantom.exit(1); } else { address = system.args[1]; page.open(address, function (status) { }); } setTimeout(function() { console.log(\"\"); console.log(\"### STEP 5: Close page and shutdown (with a delay)\"); page.render('./public/images/mainPagePart1.jpeg', {format: 'jpeg', quality: '100'}); page.close(); setTimeout(function(){ phantom.exit(); }, 3000); }, 19000); "},"node/npm/0.html":{"url":"node/npm/0.html","title":"npm","keywords":"","body":"npm "},"other/faq.html":{"url":"other/faq.html","title":"FAQ","keywords":"","body":"F.A.Q "},"other/examples.html":{"url":"other/examples.html","title":"Examples","keywords":"","body":"Examples "}}